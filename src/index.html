<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Editor</title>
  <link rel="stylesheet" href="../node_modules/codemirror/lib/codemirror.css">
  <link rel="stylesheet" href="../node_modules/codemirror/theme/material-darker.css">
  <link rel="stylesheet" href="../node_modules/codemirror/theme/monokai.css">
  <link rel="stylesheet" href="../node_modules/codemirror/theme/dracula.css">
  <link rel="stylesheet" href="../node_modules/codemirror/theme/solarized.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background-color: #1e1e1e;
      color: #d4d4d4;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #toolbar {
      display: flex;
      gap: 8px;
      padding: 8px;
      background-color: #2d2d2d;
      border-bottom: 1px solid #404040;
    }

    #toolbar button {
      padding: 6px 10px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      min-width: 32px;
      text-align: center;
      position: relative;
    }

    #toolbar button.active {
      background-color: #007acc;
      border-color: #007acc;
    }

    #toolbar button:hover {
      background-color: #4c4c4c;
    }

    #toolbar button::after {
      content: attr(data-tooltip);
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 6px;
      padding: 4px 8px;
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      z-index: 100;
    }

    #toolbar button:hover::after {
      opacity: 1;
    }

    #toolbar select {
      padding: 6px 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    .toolbar-separator {
      width: 1px;
      background-color: #505050;
      margin: 0 4px;
    }

    #main-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    #files-panel {
      width: 200px;
      background-color: #252526;
      border-right: 1px solid #404040;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #files-panel-header {
      padding: 8px 12px;
      font-size: 11px;
      text-transform: uppercase;
      color: #888;
      border-bottom: 1px solid #404040;
    }

    #files-list {
      flex: 1;
      overflow-y: auto;
    }

    .file-item {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      border-left: 3px solid transparent;
    }

    .file-item:hover {
      background-color: #2a2d2e;
    }

    .file-item.active {
      background-color: #37373d;
      border-left-color: #007acc;
    }

    .file-item.modified {
      color: #e57373;
    }

    .file-item.modified .file-name::after {
      content: ' •';
    }

    .file-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-close {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      opacity: 0;
      font-size: 14px;
      color: #888;
    }

    .file-item:hover .file-close {
      opacity: 1;
    }

    .file-close:hover {
      background-color: #404040;
      color: #fff;
    }

    .file-item.modified .file-close {
      display: none;
    }

    #editor-container {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    #btn-close {
      margin-left: auto;
      padding: 6px 10px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
    }

    #btn-close:hover {
      background-color: #d32f2f;
      color: white;
    }

    .CodeMirror {
      height: 100%;
      font-family: 'Cascadia Code', 'Fira Code', Consolas, 'Courier New', monospace;
      font-size: 14px;
    }

    .CodeMirror-selected {
      background-color: #264f78 !important;
    }

    .CodeMirror-focused .CodeMirror-selected {
      background-color: #264f78 !important;
    }

    #statusbar {
      display: flex;
      justify-content: space-between;
      padding: 4px 12px;
      background-color: #007acc;
      color: white;
      font-size: 12px;
    }

    #statusbar .left {
      display: flex;
      gap: 20px;
    }

    #statusbar .right {
      display: flex;
      gap: 20px;
    }

    #no-file-message {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-size: 16px;
    }

    /* Modal styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal {
      background-color: #2d2d2d;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      min-width: 300px;
      max-width: 400px;
    }

    .modal h3 {
      margin-bottom: 12px;
      color: #d4d4d4;
    }

    .modal p {
      margin-bottom: 20px;
      color: #999;
    }

    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .modal-buttons button {
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    .modal-buttons .btn-primary {
      background-color: #007acc;
      color: white;
      border: none;
    }

    .modal-buttons .btn-secondary {
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
    }

    .modal-buttons .btn-danger {
      background-color: #d32f2f;
      color: white;
      border: none;
    }

    .format-modal-field {
      margin-bottom: 16px;
    }

    .format-modal-field select {
      width: 100%;
      padding: 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      font-size: 13px;
    }

    .format-modal-field label {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #d4d4d4;
      font-size: 13px;
      cursor: pointer;
    }

    .format-modal-field input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    /* Search panel */
    #search-panel {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background-color: #252526;
      border-bottom: 1px solid #404040;
    }

    #search-panel input[type="text"] {
      padding: 4px 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      font-size: 13px;
      width: 180px;
      outline: none;
    }

    #search-panel input[type="text"]:focus {
      border-color: #007acc;
    }

    #search-panel button {
      padding: 4px 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      line-height: 1;
      position: relative;
    }

    #search-panel button:hover {
      background-color: #4c4c4c;
    }

    #search-panel button::after {
      content: attr(data-tooltip);
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 6px;
      padding: 4px 8px;
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      z-index: 100;
    }

    #search-panel button:hover::after {
      opacity: 1;
    }

    #search-panel label {
      display: flex;
      align-items: center;
      gap: 3px;
      color: #d4d4d4;
      font-size: 12px;
      cursor: pointer;
    }

    #search-panel input[type="checkbox"] {
      cursor: pointer;
    }

    #search-count {
      color: #888;
      font-size: 12px;
      margin-left: auto;
      white-space: nowrap;
    }

    #btn-search-close:hover {
      background-color: #d32f2f !important;
      color: white;
    }

    .search-highlight {
      background-color: rgba(255, 215, 0, 0.3);
    }

    .search-highlight-current {
      background-color: rgba(255, 165, 0, 0.6);
    }

    /* Merge view */
    #merge-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #merge-toolbar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 6px 12px;
      background-color: #252526;
      border-bottom: 1px solid #404040;
      font-size: 13px;
    }

    #merge-toolbar button {
      padding: 4px 12px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    #merge-toolbar button:hover {
      background-color: #4c4c4c;
    }

    #merge-toolbar button.merge-done {
      background-color: #007acc;
      border-color: #007acc;
      color: white;
    }

    #merge-toolbar button.merge-done:hover {
      background-color: #1e8ad6;
    }

    .merge-panel-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      background-color: #2d2d2d;
      border-bottom: 1px solid #404040;
      font-size: 12px;
      flex-shrink: 0;
      z-index: 1;
    }

    .merge-panel-header .merge-filename {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #d4d4d4;
    }

    .merge-panel-header button {
      padding: 3px 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .merge-panel-header button:hover {
      background-color: #4c4c4c;
    }

    .merge-panel-header .merge-save-btn {
      background-color: #007acc;
      border-color: #007acc;
      color: white;
    }

    .merge-panel-header .merge-save-btn:hover {
      background-color: #1e8ad6;
    }

    #merge-editors {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .merge-editor-wrap {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    .merge-editor-wrap + .merge-editor-wrap {
      border-left: 2px solid #007acc;
    }

    .merge-editor-wrap .CodeMirror {
      flex: 1;
      min-height: 0;
    }

    .merge-added {
      background-color: rgba(46, 125, 50, 0.2);
    }

    .merge-removed {
      background-color: rgba(211, 47, 47, 0.2);
    }

    .merge-accept-btn {
      display: inline-block;
      padding: 2px 8px;
      margin: 2px 0;
      background-color: #2e7d32;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
    }

    .merge-accept-btn:hover {
      background-color: #388e3c;
    }

    .merge-editor-wrap {
      display: flex;
      flex-direction: column;
    }

    .hidden {
      display: none !important;
    }

    /* Light theme styles */
    body.light-theme {
      background-color: #ffffff;
      color: #333333;
    }

    body.light-theme #toolbar {
      background-color: #f0f0f0;
      border-bottom-color: #cccccc;
    }

    body.light-theme #toolbar button {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #toolbar select {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #toolbar button:hover {
      background-color: #d0d0d0;
    }

    body.light-theme .toolbar-separator {
      background-color: #cccccc;
    }

    body.light-theme #files-panel {
      background-color: #f5f5f5;
      border-right-color: #cccccc;
    }

    body.light-theme #files-panel-header {
      color: #666666;
      border-bottom-color: #cccccc;
    }

    body.light-theme .file-item:hover {
      background-color: #e8e8e8;
    }

    body.light-theme .file-item.active {
      background-color: #e0e0e0;
    }

    body.light-theme .file-item.modified {
      color: #c62828;
    }

    body.light-theme .file-close {
      color: #666666;
    }

    body.light-theme .file-close:hover {
      background-color: #d0d0d0;
      color: #333333;
    }

    body.light-theme #no-file-message {
      color: #999999;
    }

    body.light-theme .modal {
      background-color: #ffffff;
      border-color: #cccccc;
    }

    body.light-theme .modal h3 {
      color: #333333;
    }

    body.light-theme .modal p {
      color: #666666;
    }

    body.light-theme .modal-buttons .btn-secondary {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme .format-modal-field select {
      background-color: #ffffff;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme .format-modal-field label {
      color: #333333;
    }

    body.light-theme #search-panel {
      background-color: #f0f0f0;
      border-bottom-color: #cccccc;
    }

    body.light-theme #search-panel input[type="text"] {
      background-color: #ffffff;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #search-panel button {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #search-panel button:hover {
      background-color: #d0d0d0;
    }

    body.light-theme #search-panel label {
      color: #333333;
    }

    body.light-theme #search-count {
      color: #666666;
    }

    body.light-theme #merge-toolbar {
      background-color: #f0f0f0;
      border-bottom-color: #cccccc;
    }

    body.light-theme #merge-toolbar button {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #merge-toolbar button:hover {
      background-color: #d0d0d0;
    }

    body.light-theme .merge-panel-header {
      background-color: #f0f0f0;
      border-bottom-color: #cccccc;
    }

    body.light-theme .merge-panel-header .merge-filename {
      color: #333333;
    }

    body.light-theme .merge-panel-header button {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme .merge-panel-header button:hover {
      background-color: #d0d0d0;
    }

    body.light-theme .merge-editor-wrap + .merge-editor-wrap {
      border-left-color: #007acc;
    }

    body.light-theme .merge-added {
      background-color: rgba(46, 125, 50, 0.15);
    }

    body.light-theme .merge-removed {
      background-color: rgba(211, 47, 47, 0.15);
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="btn-new" data-tooltip="New file">&#x1F4C4;</button>
    <button id="btn-open" data-tooltip="Open file">&#x1F4C2;</button>
    <button id="btn-save" data-tooltip="Save">&#x1F4BE;</button>
    <button id="btn-save-as" data-tooltip="Save As">&#x1F4E5;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-reload" data-tooltip="Reload from disk">&#x21BB;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-undo" data-tooltip="Undo">&#x21B6;</button>
    <button id="btn-redo" data-tooltip="Redo">&#x21B7;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-format" data-tooltip="Format document">&#x2261;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-wrap" data-tooltip="Toggle word wrap">&#x21A9;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-search" data-tooltip="Find and Replace">&#x1F50D;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-merge" data-tooltip="Merge file">&#x2194;</button>
    <div class="toolbar-separator"></div>
    <select id="theme-select">
      <option value="dark">Dark</option>
      <option value="light">Light</option>
      <option value="monokai">Monokai</option>
      <option value="dracula">Dracula</option>
      <option value="solarized-light">Solarized Light</option>
    </select>
    <button id="btn-close" data-tooltip="Close file">&#x2715;</button>
  </div>

  <div id="search-panel" class="hidden">
    <input type="text" id="search-input" placeholder="Find">
    <input type="text" id="replace-input" placeholder="Replace">
    <button id="btn-search-prev" data-tooltip="Previous match">&#x25B2;</button>
    <button id="btn-search-next" data-tooltip="Next match">&#x25BC;</button>
    <button id="btn-replace" data-tooltip="Replace">Replace</button>
    <button id="btn-replace-all" data-tooltip="Replace all">All</button>
    <label data-tooltip="Case sensitive"><input type="checkbox" id="search-case"> Aa</label>
    <label data-tooltip="Regular expression"><input type="checkbox" id="search-regex"> .*</label>
    <span id="search-count">No results</span>
    <button id="btn-search-close" data-tooltip="Close search">&#x2715;</button>
  </div>

  <div id="main-container">
    <div id="files-panel">
      <div id="files-panel-header">Open Files</div>
      <div id="files-list"></div>
    </div>

    <div id="editor-container">
      <textarea id="editor"></textarea>
    </div>

    <div id="merge-container" class="hidden">
      <div id="merge-toolbar">
        <button id="merge-refresh-btn">Refresh Diff</button>
        <button class="merge-done" id="merge-done-btn">Done</button>
      </div>
      <div id="merge-editors">
        <div class="merge-editor-wrap" id="merge-left-wrap">
          <div class="merge-panel-header">
            <span class="merge-filename" id="merge-left-name"></span>
            <button class="merge-save-btn" id="merge-left-save-btn">Save</button>
          </div>
          <textarea id="merge-left-editor"></textarea>
        </div>
        <div class="merge-editor-wrap" id="merge-right-wrap">
          <div class="merge-panel-header">
            <span class="merge-filename" id="merge-right-name"></span>
            <button class="merge-save-btn" id="merge-right-save-btn">Save</button>
          </div>
          <textarea id="merge-right-editor"></textarea>
        </div>
      </div>
    </div>

    <div id="no-file-message" class="hidden">
      No file open. Click "New" or "Open" to get started.
    </div>
  </div>

  <div id="statusbar">
    <div class="left">
      <span id="status-text">Ready</span>
    </div>
    <div class="right">
      <span id="status-position">Ln 1, Col 1</span>
      <span id="status-encoding">UTF-8</span>
      <span id="status-language">Plain Text</span>
    </div>
  </div>

  <!-- Save confirmation modal -->
  <div id="save-modal" class="modal-overlay hidden">
    <div class="modal">
      <h3>Unsaved Changes</h3>
      <p id="save-modal-message">Do you want to save changes before closing?</p>
      <div class="modal-buttons">
        <button class="btn-secondary" id="modal-cancel">Cancel</button>
        <button class="btn-danger" id="modal-dont-save">Don't Save</button>
        <button class="btn-primary" id="modal-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Format selection modal -->
  <div id="format-modal" class="modal-overlay hidden">
    <div class="modal">
      <h3>Select Format Type</h3>
      <p id="format-modal-message">Choose a format type for this file:</p>
      <div class="format-modal-field">
        <select id="format-type-select">
          <option value="json">JSON</option>
          <option value="xml">XML</option>
          <option value="html">HTML</option>
        </select>
      </div>
      <div class="format-modal-field">
        <label id="format-remember-label">
          <input type="checkbox" id="format-remember-checkbox">
          <span id="format-remember-text">Always use this format for this extension</span>
        </label>
      </div>
      <div class="modal-buttons">
        <button class="btn-secondary" id="format-modal-cancel">Cancel</button>
        <button class="btn-primary" id="format-modal-apply">Format</button>
      </div>
    </div>
  </div>

  <!-- Close app confirmation modal -->
  <div id="close-app-modal" class="modal-overlay hidden">
    <div class="modal">
      <h3>Unsaved Changes</h3>
      <p id="close-app-modal-message">You have unsaved files. Close without saving?</p>
      <div class="modal-buttons">
        <button class="btn-secondary" id="close-app-cancel">Cancel</button>
        <button class="btn-danger" id="close-app-confirm">Close Without Saving</button>
      </div>
    </div>
  </div>

  <script>
    const { ipcRenderer, webUtils } = require('electron');
    const path = require('path');
    const CodeMirror = require('codemirror');

    // Load language modes
    require('codemirror/mode/javascript/javascript');
    require('codemirror/mode/xml/xml');
    require('codemirror/mode/htmlmixed/htmlmixed');
    require('codemirror/mode/css/css');
    require('codemirror/mode/clike/clike');
    require('codemirror/mode/python/python');
    require('codemirror/mode/sql/sql');
    require('codemirror/mode/markdown/markdown');
    require('codemirror/mode/yaml/yaml');

    // Load editor addons
    require('codemirror/addon/edit/closebrackets');
    require('codemirror/addon/edit/matchbrackets');
    require('codemirror/addon/edit/closetag');
    require('codemirror/addon/search/searchcursor');

    // State - multiple files support
    let openFiles = []; // Array of { id, filePath, content, encoding, language, isDirty }
    let activeFileId = null;
    let fileIdCounter = 0;
    let pendingCloseAction = null; // { type: 'close' | 'closeAll', fileId }
    let isLoadingContent = false; // Flag to suppress dirty marking during programmatic content changes
    let currentTheme = 'dark'; // Theme state
    let formatMappings = {}; // Extension-to-format mappings (e.g. { ".csproj": "xml" })

    // Initialize CodeMirror
    const editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
      lineNumbers: true,
      theme: 'material-darker',
      mode: 'text/plain',
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: true,
      lineWrapping: false,
      undoDepth: 10,
      autoCloseBrackets: true,
      matchBrackets: true,
      autoCloseTags: true
    });

    // Track changes
    editor.on('change', () => {
      if (isLoadingContent) return; // Skip during programmatic content loading
      const file = getActiveFile();
      if (file && !file.isDirty) {
        file.isDirty = true;
        updateFilesList();
        updateTitle();
      }
    });

    // Track cursor position
    editor.on('cursorActivity', () => {
      const pos = editor.getCursor();
      updatePosition(pos.line + 1, pos.ch + 1);
    });

    // Button event listeners
    document.getElementById('btn-new').addEventListener('click', newFile);
    document.getElementById('btn-open').addEventListener('click', openFile);
    document.getElementById('btn-save').addEventListener('click', saveFile);
    document.getElementById('btn-save-as').addEventListener('click', saveFileAs);
    document.getElementById('btn-reload').addEventListener('click', reloadFile);
    document.getElementById('btn-close').addEventListener('click', () => {
      if (mergeActive) {
        cancelMerge();
      } else {
        closeFile(activeFileId);
      }
    });
    document.getElementById('btn-undo').addEventListener('click', () => editor.undo());
    document.getElementById('btn-redo').addEventListener('click', () => editor.redo());
    document.getElementById('btn-format').addEventListener('click', formatDocument);
    document.getElementById('btn-wrap').addEventListener('click', toggleWordWrap);
    document.getElementById('btn-search').addEventListener('click', toggleSearchPanel);
    document.getElementById('btn-merge').addEventListener('click', startMerge);
    document.getElementById('merge-refresh-btn').addEventListener('click', () => computeAndDisplayDiff());
    document.getElementById('merge-done-btn').addEventListener('click', closeMergeView);
    document.getElementById('merge-left-save-btn').addEventListener('click', () => saveMergeFile('left'));
    document.getElementById('merge-right-save-btn').addEventListener('click', () => saveMergeFile('right'));
    document.getElementById('btn-search-prev').addEventListener('click', () => navigateMatch(-1));
    document.getElementById('btn-search-next').addEventListener('click', () => navigateMatch(1));
    document.getElementById('btn-replace').addEventListener('click', replaceCurrent);
    document.getElementById('btn-replace-all').addEventListener('click', replaceAll);
    document.getElementById('btn-search-close').addEventListener('click', closeSearchPanel);

    document.getElementById('search-input').addEventListener('input', performSearch);
    document.getElementById('search-case').addEventListener('change', performSearch);
    document.getElementById('search-regex').addEventListener('change', performSearch);

    document.getElementById('search-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        navigateMatch(e.shiftKey ? -1 : 1);
      } else if (e.key === 'Escape') {
        closeSearchPanel();
      }
    });
    document.getElementById('replace-input').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeSearchPanel();
      }
    });

    document.getElementById('theme-select').addEventListener('change', (e) => {
      applyTheme(e.target.value);
      ipcRenderer.invoke('save-preference', { key: 'theme', value: e.target.value });
    });

    // Modal buttons
    document.getElementById('modal-cancel').addEventListener('click', () => {
      hideModal();
      pendingCloseAction = null;
    });
    document.getElementById('modal-dont-save').addEventListener('click', () => {
      hideModal();
      if (pendingCloseAction) {
        forceCloseFile(pendingCloseAction.fileId);
        pendingCloseAction = null;
      }
    });
    document.getElementById('modal-save').addEventListener('click', async () => {
      hideModal();
      if (pendingCloseAction) {
        const fileId = pendingCloseAction.fileId;
        pendingCloseAction = null;
        await saveFileById(fileId);
        forceCloseFile(fileId);
      }
    });

    // Format modal buttons
    document.getElementById('format-modal-cancel').addEventListener('click', () => {
      document.getElementById('format-modal').classList.add('hidden');
    });
    document.getElementById('format-modal-apply').addEventListener('click', async () => {
      const formatType = document.getElementById('format-type-select').value;
      const remember = document.getElementById('format-remember-checkbox').checked;
      document.getElementById('format-modal').classList.add('hidden');

      const file = getActiveFile();
      if (!file) return;

      if (remember && file.filePath) {
        const ext = path.extname(file.filePath).toLowerCase();
        formatMappings[ext] = formatType;
        await ipcRenderer.invoke('save-format-mappings', formatMappings);
      }

      applyFormat(formatType);
    });

    // Close app modal buttons
    document.getElementById('close-app-cancel').addEventListener('click', () => {
      document.getElementById('close-app-modal').classList.add('hidden');
    });
    document.getElementById('close-app-confirm').addEventListener('click', () => {
      document.getElementById('close-app-modal').classList.add('hidden');
      ipcRenderer.send('confirm-close');
    });

    // Load saved format mappings on startup
    ipcRenderer.invoke('load-format-mappings').then(mappings => {
      formatMappings = mappings || {};
    });

    // Load saved preferences on startup
    ipcRenderer.invoke('load-preferences').then(prefs => {
      if (prefs && prefs.theme) {
        applyTheme(prefs.theme);
      }
    });

    // IPC listeners
    ipcRenderer.on('menu-new', () => newFile());
    ipcRenderer.on('menu-save', () => saveFile());
    ipcRenderer.on('menu-save-as', () => saveFileAs());
    ipcRenderer.on('file-opened', (_, data) => loadFile(data));
    ipcRenderer.on('app-closing', () => {
      const hasUnsaved = openFiles.some(f => f.isDirty);
      if (hasUnsaved) {
        const unsavedCount = openFiles.filter(f => f.isDirty).length;
        const msg = unsavedCount === 1
          ? 'You have 1 unsaved file. Close without saving?'
          : `You have ${unsavedCount} unsaved files. Close without saving?`;
        document.getElementById('close-app-modal-message').textContent = msg;
        document.getElementById('close-app-modal').classList.remove('hidden');
      } else {
        ipcRenderer.send('confirm-close');
      }
    });

    function generateFileId() {
      return ++fileIdCounter;
    }

    function getActiveFile() {
      return openFiles.find(f => f.id === activeFileId);
    }

    function getFileById(id) {
      return openFiles.find(f => f.id === id);
    }

    function newFile() {
      const id = generateFileId();
      const file = {
        id,
        filePath: null,
        content: '',
        encoding: 'utf-8',
        language: 'plaintext',
        isDirty: false
      };
      openFiles.push(file);
      switchToFile(id);
      updateStatus('New file created');
    }

    async function openFile() {
      await ipcRenderer.invoke('open-file-dialog');
    }

    function loadFile(data) {
      // Check if file is already open
      const existingFile = openFiles.find(f => f.filePath === data.filePath);
      if (existingFile) {
        switchToFile(existingFile.id);
        updateStatus('File already open');
        return;
      }

      const id = generateFileId();
      const file = {
        id,
        filePath: data.filePath,
        content: data.content,
        encoding: data.encoding,
        language: data.language,
        isDirty: false
      };
      openFiles.push(file);
      switchToFile(id);
      updateStatus('Opened: ' + path.basename(data.filePath));
    }

    function switchToFile(id) {
      // Save current file content
      const currentFile = getActiveFile();
      if (currentFile) {
        currentFile.content = editor.getValue();
      }

      activeFileId = id;
      const file = getFileById(id);

      if (file) {
        isLoadingContent = true;
        editor.setValue(file.content);
        isLoadingContent = false;
        const mode = getCodeMirrorMode(file.language);
        editor.setOption('mode', mode);

        document.getElementById('editor-container').classList.remove('hidden');
        document.getElementById('no-file-message').classList.add('hidden');
        editor.refresh();

        updateTitle();
        updateEncoding(file.encoding.toUpperCase());
        updateLanguage(getLanguageDisplayName(file.language));
      }

      updateFilesList();
      editor.focus();
    }

    async function saveFile() {
      const file = getActiveFile();
      if (!file) return;

      file.content = editor.getValue();

      if (!file.filePath) {
        await saveFileAs();
        return;
      }

      const result = await ipcRenderer.invoke('save-file', {
        filePath: file.filePath,
        content: file.content,
        encoding: file.encoding
      });

      if (result.success) {
        file.isDirty = false;
        updateFilesList();
        updateTitle();
        updateStatus('File saved');
      } else {
        updateStatus('Error: ' + result.error);
      }
    }

    async function saveFileById(id) {
      const file = getFileById(id);
      if (!file) return;

      // If this is the active file, get latest content
      if (id === activeFileId) {
        file.content = editor.getValue();
      }

      if (!file.filePath) {
        // Switch to file first for save dialog
        switchToFile(id);
        await saveFileAs();
        return;
      }

      const result = await ipcRenderer.invoke('save-file', {
        filePath: file.filePath,
        content: file.content,
        encoding: file.encoding
      });

      if (result.success) {
        file.isDirty = false;
        updateFilesList();
        updateTitle();
        updateStatus('File saved');
      } else {
        updateStatus('Error: ' + result.error);
      }
    }

    async function saveFileAs() {
      const file = getActiveFile();
      if (!file) return;

      file.content = editor.getValue();
      const suggestedName = file.filePath ? path.basename(file.filePath) : 'untitled.txt';

      const result = await ipcRenderer.invoke('save-file-dialog', {
        content: file.content,
        encoding: file.encoding,
        suggestedName
      });

      if (result.success) {
        file.filePath = result.filePath;
        file.isDirty = false;
        file.language = getLanguageFromPath(result.filePath);
        const mode = getCodeMirrorMode(file.language);
        editor.setOption('mode', mode);
        updateFilesList();
        updateTitle();
        updateLanguage(getLanguageDisplayName(file.language));
        updateStatus('File saved');
      } else if (!result.canceled) {
        updateStatus('Error: ' + result.error);
      }
    }

    async function reloadFile() {
      const file = getActiveFile();
      if (!file || !file.filePath) {
        updateStatus('Cannot reload: No file path');
        return;
      }

      if (file.isDirty) {
        const confirmed = confirm('Discard unsaved changes and reload from disk?');
        if (!confirmed) return;
      }

      try {
        const data = await ipcRenderer.invoke('reload-file', { filePath: file.filePath });
        if (data) {
          file.content = data.content;
          file.encoding = data.encoding;
          file.isDirty = false;
          isLoadingContent = true;
          editor.setValue(file.content);
          isLoadingContent = false;
          updateFilesList();
          updateTitle();
          updateEncoding(file.encoding.toUpperCase());
          updateStatus('File reloaded');
        }
      } catch (err) {
        updateStatus('Error reloading file');
      }
    }

    function closeFile(id) {
      const file = getFileById(id);
      if (!file) return;

      if (file.isDirty) {
        pendingCloseAction = { type: 'close', fileId: id };
        const fileName = file.filePath ? path.basename(file.filePath) : 'Untitled';
        document.getElementById('save-modal-message').textContent =
          `Do you want to save changes to "${fileName}" before closing?`;
        showModal();
      } else {
        forceCloseFile(id);
      }
    }

    function forceCloseFile(id) {
      const index = openFiles.findIndex(f => f.id === id);
      if (index === -1) return;

      openFiles.splice(index, 1);

      if (openFiles.length === 0) {
        activeFileId = null;
        editor.setValue('');
        document.getElementById('editor-container').classList.add('hidden');
        document.getElementById('no-file-message').classList.remove('hidden');
        updateTitle();
        updateStatus('Ready');
      } else if (activeFileId === id) {
        // Switch to another file
        const newIndex = Math.min(index, openFiles.length - 1);
        switchToFile(openFiles[newIndex].id);
      }

      updateFilesList();
    }

    function showModal() {
      document.getElementById('save-modal').classList.remove('hidden');
    }

    function hideModal() {
      document.getElementById('save-modal').classList.add('hidden');
    }

    function toggleWordWrap() {
      const current = editor.getOption('lineWrapping');
      editor.setOption('lineWrapping', !current);
      const btn = document.getElementById('btn-wrap');
      btn.classList.toggle('active', !current);
      btn.setAttribute('data-tooltip', !current ? 'Word wrap on' : 'Toggle word wrap');
    }

    const themeMap = {
      'dark': { cm: 'material-darker', bodyClass: '' },
      'light': { cm: 'default', bodyClass: 'light-theme' },
      'monokai': { cm: 'monokai', bodyClass: '' },
      'dracula': { cm: 'dracula', bodyClass: '' },
      'solarized-light': { cm: 'solarized light', bodyClass: 'light-theme' }
    };

    function applyTheme(themeName) {
      const theme = themeMap[themeName];
      if (!theme) return;
      currentTheme = themeName;

      // Remove all theme body classes, then apply if needed
      document.body.classList.remove('light-theme');
      if (theme.bodyClass) {
        document.body.classList.add(theme.bodyClass);
      }
      editor.setOption('theme', theme.cm);
      document.getElementById('theme-select').value = themeName;
    }

    function getFormatType(file) {
      const supportedFormats = ['json', 'xml', 'html'];
      if (supportedFormats.includes(file.language)) {
        return file.language;
      }
      if (file.filePath) {
        const ext = path.extname(file.filePath).toLowerCase();
        if (formatMappings[ext]) {
          return formatMappings[ext];
        }
      }
      return null;
    }

    function applyFormat(formatType) {
      const file = getActiveFile();
      if (!file) return;

      // Apply syntax highlighting for the selected format type
      file.language = formatType;
      editor.setOption('mode', getCodeMirrorMode(formatType));
      updateLanguage(getLanguageDisplayName(formatType));

      const content = editor.getValue();
      let formatted;

      try {
        if (formatType === 'json') {
          formatted = formatJSON(content);
        } else if (formatType === 'xml') {
          formatted = formatXML(content);
        } else if (formatType === 'html') {
          formatted = formatHTML(content);
        } else {
          updateStatus('Unknown format type: ' + formatType);
          return;
        }

        if (formatted !== null && formatted !== content) {
          isLoadingContent = true;
          editor.setValue(formatted);
          isLoadingContent = false;
          file.isDirty = true;
          updateFilesList();
          updateTitle();
          updateStatus('Document formatted as ' + formatType.toUpperCase());
        } else {
          updateStatus('Document highlighted as ' + formatType.toUpperCase());
        }
      } catch (err) {
        updateStatus('Format error: ' + err.message);
      }
    }

    function showFormatModal(file) {
      const ext = file.filePath ? path.extname(file.filePath).toLowerCase() : '';
      const msg = ext
        ? 'Choose a format type for ' + ext + ' files:'
        : 'Choose a format type:';
      document.getElementById('format-modal-message').textContent = msg;

      const rememberLabel = document.getElementById('format-remember-label');
      if (ext) {
        rememberLabel.classList.remove('hidden');
        document.getElementById('format-remember-text').textContent =
          'Always use this format for ' + ext + ' files';
      } else {
        rememberLabel.classList.add('hidden');
      }

      document.getElementById('format-remember-checkbox').checked = false;
      document.getElementById('format-type-select').value = 'xml';
      document.getElementById('format-modal').classList.remove('hidden');
    }

    function formatDocument() {
      const file = getActiveFile();
      if (!file) {
        updateStatus('No file open');
        return;
      }

      const formatType = getFormatType(file);
      if (formatType) {
        applyFormat(formatType);
      } else {
        showFormatModal(file);
      }
    }

    function formatJSON(content) {
      const parsed = JSON.parse(content);
      return JSON.stringify(parsed, null, 2);
    }

    function formatXML(content) {
      const PADDING = '  ';
      let formatted = '';
      let indent = 0;

      // Remove existing whitespace between tags
      const xml = content.replace(/>\s*</g, '><').trim();

      xml.split(/(<[^>]+>)/g).forEach(node => {
        if (!node.trim()) return;

        if (node.match(/^<\?/)) {
          // XML declaration
          formatted += node + '\n';
        } else if (node.match(/^<\//)) {
          // Closing tag
          indent--;
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^<[^/].*[^/]>$/)) {
          // Opening tag (not self-closing)
          formatted += PADDING.repeat(indent) + node + '\n';
          indent++;
        } else if (node.match(/^<.*\/>$/)) {
          // Self-closing tag
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^</)) {
          // Other tags
          formatted += PADDING.repeat(indent) + node + '\n';
        } else {
          // Text content
          if (node.trim()) {
            formatted += PADDING.repeat(indent) + node.trim() + '\n';
          }
        }
      });

      return formatted.trim();
    }

    function formatHTML(content) {
      const PADDING = '  ';
      let formatted = '';
      let indent = 0;

      // Inline elements that shouldn't force newlines
      const inlineElements = ['a', 'span', 'strong', 'em', 'b', 'i', 'u', 'small', 'code', 'br', 'img'];
      // Void elements (self-closing)
      const voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

      // Remove existing whitespace between tags
      const html = content.replace(/>\s+</g, '><').trim();

      html.split(/(<[^>]+>)/g).forEach(node => {
        if (!node.trim()) return;

        const tagMatch = node.match(/^<\/?(\w+)/);
        const tagName = tagMatch ? tagMatch[1].toLowerCase() : '';

        if (node.match(/^<!DOCTYPE/i)) {
          // DOCTYPE
          formatted += node + '\n';
        } else if (node.match(/^<!--/)) {
          // Comment
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^<\//)) {
          // Closing tag
          indent = Math.max(0, indent - 1);
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^<[^/]/) && !voidElements.includes(tagName)) {
          // Opening tag (not void)
          formatted += PADDING.repeat(indent) + node + '\n';
          indent++;
        } else if (node.match(/^</)) {
          // Void/self-closing tag
          formatted += PADDING.repeat(indent) + node + '\n';
        } else {
          // Text content
          if (node.trim()) {
            formatted += PADDING.repeat(indent) + node.trim() + '\n';
          }
        }
      });

      return formatted.trim();
    }

    function updateTitle() {
      const file = getActiveFile();
      if (file) {
        const fileName = file.filePath ? path.basename(file.filePath) : 'Untitled';
        document.title = (file.isDirty ? '* ' : '') + fileName + ' - Text Editor';
      } else {
        document.title = 'Text Editor';
      }
    }

    function updateStatus(text) {
      document.getElementById('status-text').textContent = text;
    }

    function updatePosition(line, col) {
      document.getElementById('status-position').textContent = 'Ln ' + line + ', Col ' + col;
    }

    function updateEncoding(encoding) {
      document.getElementById('status-encoding').textContent = encoding;
    }

    function updateLanguage(language) {
      document.getElementById('status-language').textContent = language;
    }

    function updateFilesList() {
      const container = document.getElementById('files-list');
      container.innerHTML = '';

      openFiles.forEach(file => {
        const div = document.createElement('div');
        div.className = 'file-item' +
          (file.id === activeFileId ? ' active' : '') +
          (file.isDirty ? ' modified' : '');

        const nameSpan = document.createElement('span');
        nameSpan.className = 'file-name';
        nameSpan.textContent = file.filePath ? path.basename(file.filePath) : 'Untitled';
        nameSpan.title = file.filePath || 'Untitled';

        div.appendChild(nameSpan);

        // Only show close button for non-modified files
        if (!file.isDirty) {
          const closeBtn = document.createElement('span');
          closeBtn.className = 'file-close';
          closeBtn.textContent = '×';
          closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeFile(file.id);
          });
          div.appendChild(closeBtn);
        }

        div.addEventListener('click', () => switchToFile(file.id));
        container.appendChild(div);
      });
    }

    function getCodeMirrorMode(language) {
      const modes = {
        'html': 'htmlmixed',
        'xml': 'xml',
        'json': { name: 'javascript', json: true },
        'javascript': 'javascript',
        'typescript': { name: 'javascript', typescript: true },
        'css': 'css',
        'scss': 'text/x-scss',
        'less': 'text/x-less',
        'csharp': 'text/x-csharp',
        'c': 'text/x-csrc',
        'cpp': 'text/x-c++src',
        'java': 'text/x-java',
        'python': 'python',
        'sql': 'sql',
        'markdown': 'markdown',
        'yaml': 'yaml',
        'plaintext': 'text/plain'
      };
      return modes[language] || 'text/plain';
    }

    function getLanguageDisplayName(lang) {
      const names = {
        'plaintext': 'Plain Text',
        'html': 'HTML',
        'xml': 'XML',
        'json': 'JSON',
        'javascript': 'JavaScript',
        'typescript': 'TypeScript',
        'csharp': 'C#',
        'css': 'CSS',
        'scss': 'SCSS',
        'less': 'Less',
        'java': 'Java',
        'sql': 'SQL',
        'c': 'C',
        'cpp': 'C++',
        'python': 'Python',
        'markdown': 'Markdown',
        'yaml': 'YAML'
      };
      return names[lang] || lang;
    }

    function getLanguageFromPath(filePath) {
      const ext = path.extname(filePath).toLowerCase();
      const map = {
        '.html': 'html',
        '.htm': 'html',
        '.xml': 'xml',
        '.xaml': 'xml',
        '.json': 'json',
        '.js': 'javascript',
        '.jsx': 'javascript',
        '.mjs': 'javascript',
        '.ts': 'typescript',
        '.tsx': 'typescript',
        '.cs': 'csharp',
        '.css': 'css',
        '.scss': 'scss',
        '.less': 'less',
        '.java': 'java',
        '.sql': 'sql',
        '.c': 'c',
        '.h': 'c',
        '.cpp': 'cpp',
        '.hpp': 'cpp',
        '.py': 'python',
        '.md': 'markdown',
        '.yaml': 'yaml',
        '.yml': 'yaml',
        '.txt': 'plaintext'
      };
      return map[ext] || 'plaintext';
    }

    // Search and replace state
    let searchMarks = [];
    let searchMatches = []; // Each entry: { from, to, editor } where editor is the CodeMirror instance
    let currentMatchIndex = -1;

    function toggleSearchPanel() {
      const panel = document.getElementById('search-panel');
      if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        updateSearchReplaceVisibility();
        if (!mergeActive) {
          const selection = editor.getSelection();
          if (selection) {
            document.getElementById('search-input').value = selection;
          }
        }
        document.getElementById('search-input').focus();
        document.getElementById('search-input').select();
        if (document.getElementById('search-input').value) {
          performSearch();
        }
      } else {
        closeSearchPanel();
      }
    }

    function updateSearchReplaceVisibility() {
      // Replace is always available, including in merge mode
    }

    function closeSearchPanel() {
      document.getElementById('search-panel').classList.add('hidden');
      clearSearchHighlights();
      if (mergeActive) {
        mergeLeftEditor.focus();
      } else {
        editor.focus();
      }
    }

    function clearSearchHighlights() {
      searchMarks.forEach(m => m.clear());
      searchMarks = [];
      searchMatches = [];
      currentMatchIndex = -1;
      document.getElementById('search-count').textContent = 'No results';
    }

    function buildSearchQuery() {
      const query = document.getElementById('search-input').value;
      if (!query) return null;

      const caseSensitive = document.getElementById('search-case').checked;
      const useRegex = document.getElementById('search-regex').checked;

      if (useRegex) {
        try {
          return { query: new RegExp(query, caseSensitive ? 'g' : 'gi'), caseSensitive };
        } catch (e) {
          document.getElementById('search-count').textContent = 'Invalid regex';
          return null;
        }
      }
      return { query, caseSensitive };
    }

    function searchInEditor(ed, searchQuery, caseSensitive) {
      const matches = [];
      const marks = [];
      const cursor = ed.getSearchCursor(searchQuery, null, !caseSensitive);
      while (cursor.findNext()) {
        const from = cursor.from();
        const to = cursor.to();
        matches.push({ from, to, editor: ed });
        marks.push(ed.markText(from, to, { className: 'search-highlight' }));
      }
      return { matches, marks };
    }

    function performSearch() {
      clearSearchHighlights();
      const sq = buildSearchQuery();
      if (!sq) return;

      if (mergeActive) {
        // Search left editor first, then right editor
        const left = searchInEditor(mergeLeftEditor, sq.query, sq.caseSensitive);
        const right = searchInEditor(mergeRightEditor, sq.query, sq.caseSensitive);
        searchMatches = [...left.matches, ...right.matches];
        searchMarks = [...left.marks, ...right.marks];
      } else {
        const result = searchInEditor(editor, sq.query, sq.caseSensitive);
        searchMatches = result.matches;
        searchMarks = result.marks;
      }

      if (searchMatches.length > 0) {
        highlightCurrentMatch(0);
      } else {
        document.getElementById('search-count').textContent = 'No results';
      }
    }

    function highlightCurrentMatch(index) {
      // Remove previous current highlight
      if (currentMatchIndex >= 0 && currentMatchIndex < searchMarks.length) {
        searchMarks[currentMatchIndex].clear();
        const prev = searchMatches[currentMatchIndex];
        searchMarks[currentMatchIndex] = prev.editor.markText(prev.from, prev.to, { className: 'search-highlight' });
      }

      currentMatchIndex = index;
      const match = searchMatches[currentMatchIndex];

      // Apply current highlight
      searchMarks[currentMatchIndex].clear();
      searchMarks[currentMatchIndex] = match.editor.markText(match.from, match.to, { className: 'search-highlight-current' });

      match.editor.scrollIntoView({ from: match.from, to: match.to }, 50);
      match.editor.setCursor(match.from);

      // Only focus the editor if the search input doesn't have focus
      const searchInput = document.getElementById('search-input');
      if (document.activeElement !== searchInput) {
        match.editor.focus();
      }

      document.getElementById('search-count').textContent =
        (currentMatchIndex + 1) + ' of ' + searchMatches.length;
    }

    function navigateMatch(direction) {
      if (searchMatches.length === 0) {
        performSearch();
        return;
      }

      let newIndex = currentMatchIndex + direction;
      if (newIndex >= searchMatches.length) newIndex = 0;
      if (newIndex < 0) newIndex = searchMatches.length - 1;
      highlightCurrentMatch(newIndex);
    }

    function replaceCurrent() {
      if (currentMatchIndex < 0 || currentMatchIndex >= searchMatches.length) return;
      const replaceText = document.getElementById('replace-input').value;
      const match = searchMatches[currentMatchIndex];

      match.editor.replaceRange(replaceText, match.from, match.to);
      performSearch();
    }

    function replaceAll() {
      if (searchMatches.length === 0) return;
      const replaceText = document.getElementById('replace-input').value;
      const count = searchMatches.length;

      // Replace from bottom to top to preserve positions, grouped by editor
      if (mergeActive) {
        const leftMatches = searchMatches.filter(m => m.editor === mergeLeftEditor).reverse();
        const rightMatches = searchMatches.filter(m => m.editor === mergeRightEditor).reverse();
        mergeLeftEditor.operation(() => {
          leftMatches.forEach(m => mergeLeftEditor.replaceRange(replaceText, m.from, m.to));
        });
        mergeRightEditor.operation(() => {
          rightMatches.forEach(m => mergeRightEditor.replaceRange(replaceText, m.from, m.to));
        });
      } else {
        editor.operation(() => {
          for (let i = searchMatches.length - 1; i >= 0; i--) {
            searchMatches[i].editor.replaceRange(replaceText, searchMatches[i].from, searchMatches[i].to);
          }
        });
      }

      clearSearchHighlights();
      updateStatus('Replaced ' + count + ' occurrence' + (count !== 1 ? 's' : ''));
    }

    // Keyboard shortcuts for search
    document.addEventListener('keydown', (e) => {
      const mod = process.platform === 'darwin' ? e.metaKey : e.ctrlKey;
      if (mod && e.key === 'f') {
        e.preventDefault();
        if (document.getElementById('search-panel').classList.contains('hidden')) {
          toggleSearchPanel();
        } else {
          document.getElementById('search-input').focus();
          document.getElementById('search-input').select();
        }
      } else if (mod && e.key === 'h') {
        e.preventDefault();
        if (document.getElementById('search-panel').classList.contains('hidden')) {
          toggleSearchPanel();
        }
        document.getElementById('replace-input').focus();
      }
    });

    // Merge view
    const mergeLeftEditor = CodeMirror.fromTextArea(document.getElementById('merge-left-editor'), {
      lineNumbers: true,
      theme: 'material-darker',
      mode: 'text/plain',
      readOnly: false
    });

    const mergeRightEditor = CodeMirror.fromTextArea(document.getElementById('merge-right-editor'), {
      lineNumbers: true,
      theme: 'material-darker',
      mode: 'text/plain',
      readOnly: false
    });

    let mergeActive = false;
    let mergeHunks = [];
    let mergeMarks = [];
    let mergeWidgets = [];
    let mergeLeftFilePath = null;
    let mergeRightFilePath = null;
    let mergeLeftEncoding = 'utf-8';
    let mergeRightEncoding = 'utf-8';
    let mergeOriginalLeftContent = '';
    let mergeOriginalRightContent = '';

    // Scroll sync between merge editors
    let mergeSyncScroll = true;
    mergeLeftEditor.on('scroll', () => {
      if (!mergeSyncScroll) return;
      mergeSyncScroll = false;
      const scrollInfo = mergeLeftEditor.getScrollInfo();
      mergeRightEditor.scrollTo(scrollInfo.left, scrollInfo.top);
      mergeSyncScroll = true;
    });
    mergeRightEditor.on('scroll', () => {
      if (!mergeSyncScroll) return;
      mergeSyncScroll = false;
      const scrollInfo = mergeRightEditor.getScrollInfo();
      mergeLeftEditor.scrollTo(scrollInfo.left, scrollInfo.top);
      mergeSyncScroll = true;
    });

    // LCS-based line diff algorithm
    function computeDiff(leftLines, rightLines) {
      const m = leftLines.length;
      const n = rightLines.length;

      // Build LCS table
      const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (leftLines[i - 1] === rightLines[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
          }
        }
      }

      // Backtrack to find diff hunks
      const result = [];
      let i = m, j = n;
      const ops = [];

      while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && leftLines[i - 1] === rightLines[j - 1]) {
          ops.push({ type: 'equal', leftIdx: i - 1, rightIdx: j - 1 });
          i--; j--;
        } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
          ops.push({ type: 'added', rightIdx: j - 1 });
          j--;
        } else {
          ops.push({ type: 'removed', leftIdx: i - 1 });
          i--;
        }
      }

      ops.reverse();

      // Group consecutive non-equal ops into hunks
      const hunks = [];
      let currentHunk = null;

      ops.forEach(op => {
        if (op.type === 'equal') {
          if (currentHunk) {
            hunks.push(currentHunk);
            currentHunk = null;
          }
        } else {
          if (!currentHunk) {
            currentHunk = {
              leftStart: op.type === 'removed' ? op.leftIdx : -1,
              leftLines: [],
              rightStart: op.type === 'added' ? op.rightIdx : -1,
              rightLines: []
            };
          }
          if (op.type === 'removed') {
            if (currentHunk.leftStart === -1) currentHunk.leftStart = op.leftIdx;
            currentHunk.leftLines.push(leftLines[op.leftIdx]);
          } else {
            if (currentHunk.rightStart === -1) currentHunk.rightStart = op.rightIdx;
            currentHunk.rightLines.push(rightLines[op.rightIdx]);
          }
        }
      });

      if (currentHunk) hunks.push(currentHunk);
      return hunks;
    }

    async function startMerge() {
      const file = getActiveFile();
      if (!file) {
        updateStatus('No file open to merge');
        return;
      }

      // Save current editor content
      file.content = editor.getValue();

      // Open file dialog for the incoming file
      const data = await ipcRenderer.invoke('reload-file-dialog');
      if (!data) return;

      // Store file paths and encodings for independent saving
      mergeLeftFilePath = file.filePath;
      mergeRightFilePath = data.filePath;
      mergeLeftEncoding = file.encoding || 'utf-8';
      mergeRightEncoding = data.encoding || 'utf-8';

      // Enter merge mode
      mergeActive = true;
      document.getElementById('editor-container').classList.add('hidden');
      document.getElementById('merge-container').classList.remove('hidden');
      document.getElementById('files-panel').classList.add('hidden');

      // Set filenames in headers
      const leftName = file.filePath ? path.basename(file.filePath) : 'Untitled';
      const rightName = data.filePath ? path.basename(data.filePath) : 'Unknown';
      document.getElementById('merge-left-name').textContent = leftName;
      document.getElementById('merge-right-name').textContent = rightName;

      // Apply current theme to merge editors
      const theme = themeMap[currentTheme];
      if (theme) {
        mergeLeftEditor.setOption('theme', theme.cm);
        mergeRightEditor.setOption('theme', theme.cm);
      }

      // Set modes
      const leftMode = getCodeMirrorMode(file.language);
      const rightMode = getCodeMirrorMode(data.language || 'plaintext');
      mergeLeftEditor.setOption('mode', leftMode);
      mergeRightEditor.setOption('mode', rightMode);

      // Load content and store originals for cancel detection
      mergeLeftEditor.setValue(file.content);
      mergeRightEditor.setValue(data.content);
      mergeOriginalLeftContent = file.content;
      mergeOriginalRightContent = data.content;

      mergeLeftEditor.refresh();
      mergeRightEditor.refresh();

      // Compute and display diff
      computeAndDisplayDiff();

      updateStatus('Merge mode: ' + leftName + ' vs ' + rightName);
    }

    function computeAndDisplayDiff() {
      // Clear previous marks and widgets
      clearMergeMarks();

      const leftLines = mergeLeftEditor.getValue().split('\n');
      const rightLines = mergeRightEditor.getValue().split('\n');

      mergeHunks = computeDiff(leftLines, rightLines);

      mergeHunks.forEach((hunk, hunkIndex) => {
        // Mark removed lines in left editor (red)
        if (hunk.leftLines.length > 0 && hunk.leftStart >= 0) {
          for (let i = 0; i < hunk.leftLines.length; i++) {
            const line = hunk.leftStart + i;
            if (line < mergeLeftEditor.lineCount()) {
              mergeLeftEditor.addLineClass(line, 'background', 'merge-removed');
              mergeMarks.push({ editor: 'left', line, type: 'class' });
            }
          }
        }

        // Mark added lines in right editor (green)
        if (hunk.rightLines.length > 0 && hunk.rightStart >= 0) {
          for (let i = 0; i < hunk.rightLines.length; i++) {
            const line = hunk.rightStart + i;
            if (line < mergeRightEditor.lineCount()) {
              mergeRightEditor.addLineClass(line, 'background', 'merge-added');
              mergeMarks.push({ editor: 'right', line, type: 'class' });
            }
          }
        }

        // Add "Accept →" button on left editor (push left content to right)
        const leftInsertLine = hunk.leftStart >= 0 ? hunk.leftStart : 0;
        if (leftInsertLine < mergeLeftEditor.lineCount() && hunk.leftLines.length > 0) {
          const btnToRight = document.createElement('button');
          btnToRight.className = 'merge-accept-btn';
          btnToRight.textContent = 'Push to right \u2192';
          btnToRight.addEventListener('click', () => acceptHunkTo(hunkIndex, 'right'));
          const widget = mergeLeftEditor.addLineWidget(leftInsertLine, btnToRight, { above: true });
          mergeWidgets.push(widget);
        }

        // Add "← Accept" button on right editor (push right content to left)
        const rightInsertLine = hunk.rightStart >= 0 ? hunk.rightStart : 0;
        if (rightInsertLine < mergeRightEditor.lineCount() && hunk.rightLines.length > 0) {
          const btnToLeft = document.createElement('button');
          btnToLeft.className = 'merge-accept-btn';
          btnToLeft.textContent = '\u2190 Push to left';
          btnToLeft.addEventListener('click', () => acceptHunkTo(hunkIndex, 'left'));
          const widget = mergeRightEditor.addLineWidget(rightInsertLine, btnToLeft, { above: true });
          mergeWidgets.push(widget);
        }
      });
    }

    function clearMergeMarks() {
      mergeMarks.forEach(m => {
        if (m.type === 'class') {
          const ed = m.editor === 'left' ? mergeLeftEditor : mergeRightEditor;
          ed.removeLineClass(m.line, 'background');
        }
      });
      mergeMarks = [];
      mergeWidgets.forEach(w => w.clear());
      mergeWidgets = [];
      mergeHunks = [];
    }

    function acceptHunkTo(hunkIndex, direction) {
      const hunk = mergeHunks[hunkIndex];
      if (!hunk) return;

      if (direction === 'left') {
        // Replace left content with right content
        if (hunk.leftLines.length > 0 && hunk.leftStart >= 0) {
          const from = { line: hunk.leftStart, ch: 0 };
          const toLine = hunk.leftStart + hunk.leftLines.length - 1;
          const to = { line: toLine, ch: mergeLeftEditor.getLine(toLine).length };
          mergeLeftEditor.replaceRange(hunk.rightLines.join('\n'), from, to);
        } else if (hunk.rightLines.length > 0) {
          const insertAt = hunk.leftStart >= 0 ? hunk.leftStart : mergeLeftEditor.lineCount();
          mergeLeftEditor.replaceRange(hunk.rightLines.join('\n') + '\n', { line: insertAt, ch: 0 });
        }
      } else {
        // Replace right content with left content
        if (hunk.rightLines.length > 0 && hunk.rightStart >= 0) {
          const from = { line: hunk.rightStart, ch: 0 };
          const toLine = hunk.rightStart + hunk.rightLines.length - 1;
          const to = { line: toLine, ch: mergeRightEditor.getLine(toLine).length };
          mergeRightEditor.replaceRange(hunk.leftLines.join('\n'), from, to);
        } else if (hunk.leftLines.length > 0) {
          const insertAt = hunk.rightStart >= 0 ? hunk.rightStart : mergeRightEditor.lineCount();
          mergeRightEditor.replaceRange(hunk.leftLines.join('\n') + '\n', { line: insertAt, ch: 0 });
        }
      }

      // Recompute diff
      computeAndDisplayDiff();
    }

    async function saveMergeFile(side) {
      const filePath = side === 'left' ? mergeLeftFilePath : mergeRightFilePath;
      const encoding = side === 'left' ? mergeLeftEncoding : mergeRightEncoding;
      const ed = side === 'left' ? mergeLeftEditor : mergeRightEditor;
      const content = ed.getValue();

      if (!filePath) {
        updateStatus('Cannot save: no file path for ' + side + ' panel');
        return;
      }

      const result = await ipcRenderer.invoke('save-file', { filePath, content, encoding });
      if (result.success) {
        updateStatus('Saved: ' + path.basename(filePath));
      } else {
        updateStatus('Error saving: ' + result.error);
      }
    }

    function cancelMerge() {
      if (!mergeActive) return;

      const hasChanges =
        mergeLeftEditor.getValue() !== mergeOriginalLeftContent ||
        mergeRightEditor.getValue() !== mergeOriginalRightContent;

      if (hasChanges) {
        if (!confirm('You have unsaved merge changes. Discard and close?')) {
          return;
        }
      }

      exitMergeMode();
      updateStatus('Merge cancelled');
    }

    function closeMergeView() {
      const file = getActiveFile();
      if (file) {
        const mergedContent = mergeLeftEditor.getValue();
        if (mergedContent !== file.content) {
          file.content = mergedContent;
          file.isDirty = true;
          isLoadingContent = true;
          editor.setValue(file.content);
          isLoadingContent = false;
          updateFilesList();
          updateTitle();
        }
      }

      exitMergeMode();
      updateStatus('Merge complete');
    }

    function exitMergeMode() {
      clearMergeMarks();
      mergeActive = false;
      mergeLeftFilePath = null;
      mergeRightFilePath = null;
      mergeLeftEncoding = 'utf-8';
      mergeRightEncoding = 'utf-8';
      mergeOriginalLeftContent = '';
      mergeOriginalRightContent = '';
      document.getElementById('merge-container').classList.add('hidden');
      document.getElementById('editor-container').classList.remove('hidden');
      document.getElementById('files-panel').classList.remove('hidden');
      editor.refresh();
      editor.focus();
    }

    // Drag and drop file opening (capture phase to intercept before CodeMirror)
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, true);
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      const file = e.dataTransfer.files[0];
      if (!file) return;
      const filePath = webUtils.getPathForFile(file);
      if (!filePath) return;
      const data = await ipcRenderer.invoke('reload-file', { filePath });
      if (data) {
        loadFile(data);
        ipcRenderer.send('add-recent-file', filePath);
      }
    }, true);

    // Initialize - create a new empty file on startup
    newFile();
  </script>
</body>
</html>
