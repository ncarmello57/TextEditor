<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Editor</title>
  <link rel="stylesheet" href="../node_modules/codemirror/lib/codemirror.css">
  <link rel="stylesheet" href="../node_modules/codemirror/theme/material-darker.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background-color: #1e1e1e;
      color: #d4d4d4;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #toolbar {
      display: flex;
      gap: 8px;
      padding: 8px;
      background-color: #2d2d2d;
      border-bottom: 1px solid #404040;
    }

    #toolbar button {
      padding: 6px 12px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    #toolbar button:hover {
      background-color: #4c4c4c;
    }

    .toolbar-separator {
      width: 1px;
      background-color: #505050;
      margin: 0 4px;
    }

    #main-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    #files-panel {
      width: 200px;
      background-color: #252526;
      border-right: 1px solid #404040;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #files-panel-header {
      padding: 8px 12px;
      font-size: 11px;
      text-transform: uppercase;
      color: #888;
      border-bottom: 1px solid #404040;
    }

    #files-list {
      flex: 1;
      overflow-y: auto;
    }

    .file-item {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      border-left: 3px solid transparent;
    }

    .file-item:hover {
      background-color: #2a2d2e;
    }

    .file-item.active {
      background-color: #37373d;
      border-left-color: #007acc;
    }

    .file-item.modified {
      color: #e57373;
    }

    .file-item.modified .file-name::after {
      content: ' •';
    }

    .file-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-close {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      opacity: 0;
      font-size: 14px;
      color: #888;
    }

    .file-item:hover .file-close {
      opacity: 1;
    }

    .file-close:hover {
      background-color: #404040;
      color: #fff;
    }

    .file-item.modified .file-close {
      display: none;
    }

    #editor-container {
      flex: 1;
      overflow: hidden;
    }

    .CodeMirror {
      height: 100%;
      font-family: 'Cascadia Code', 'Fira Code', Consolas, 'Courier New', monospace;
      font-size: 14px;
    }

    .CodeMirror-selected {
      background-color: #264f78 !important;
    }

    .CodeMirror-focused .CodeMirror-selected {
      background-color: #264f78 !important;
    }

    #statusbar {
      display: flex;
      justify-content: space-between;
      padding: 4px 12px;
      background-color: #007acc;
      color: white;
      font-size: 12px;
    }

    #statusbar .left {
      display: flex;
      gap: 20px;
    }

    #statusbar .right {
      display: flex;
      gap: 20px;
    }

    #no-file-message {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-size: 16px;
    }

    /* Modal styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal {
      background-color: #2d2d2d;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      min-width: 300px;
      max-width: 400px;
    }

    .modal h3 {
      margin-bottom: 12px;
      color: #d4d4d4;
    }

    .modal p {
      margin-bottom: 20px;
      color: #999;
    }

    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .modal-buttons button {
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    .modal-buttons .btn-primary {
      background-color: #007acc;
      color: white;
      border: none;
    }

    .modal-buttons .btn-secondary {
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
    }

    .modal-buttons .btn-danger {
      background-color: #d32f2f;
      color: white;
      border: none;
    }

    .format-modal-field {
      margin-bottom: 16px;
    }

    .format-modal-field select {
      width: 100%;
      padding: 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      font-size: 13px;
    }

    .format-modal-field label {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #d4d4d4;
      font-size: 13px;
      cursor: pointer;
    }

    .format-modal-field input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .hidden {
      display: none !important;
    }

    /* Light theme styles */
    body.light-theme {
      background-color: #ffffff;
      color: #333333;
    }

    body.light-theme #toolbar {
      background-color: #f0f0f0;
      border-bottom-color: #cccccc;
    }

    body.light-theme #toolbar button {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #toolbar button:hover {
      background-color: #d0d0d0;
    }

    body.light-theme .toolbar-separator {
      background-color: #cccccc;
    }

    body.light-theme #files-panel {
      background-color: #f5f5f5;
      border-right-color: #cccccc;
    }

    body.light-theme #files-panel-header {
      color: #666666;
      border-bottom-color: #cccccc;
    }

    body.light-theme .file-item:hover {
      background-color: #e8e8e8;
    }

    body.light-theme .file-item.active {
      background-color: #e0e0e0;
    }

    body.light-theme .file-item.modified {
      color: #c62828;
    }

    body.light-theme .file-close {
      color: #666666;
    }

    body.light-theme .file-close:hover {
      background-color: #d0d0d0;
      color: #333333;
    }

    body.light-theme #no-file-message {
      color: #999999;
    }

    body.light-theme .modal {
      background-color: #ffffff;
      border-color: #cccccc;
    }

    body.light-theme .modal h3 {
      color: #333333;
    }

    body.light-theme .modal p {
      color: #666666;
    }

    body.light-theme .modal-buttons .btn-secondary {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme .format-modal-field select {
      background-color: #ffffff;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme .format-modal-field label {
      color: #333333;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="btn-new">New</button>
    <button id="btn-open">Open</button>
    <button id="btn-save">Save</button>
    <button id="btn-save-as">Save As</button>
    <div class="toolbar-separator"></div>
    <button id="btn-reload">Reload</button>
    <button id="btn-close">Close</button>
    <div class="toolbar-separator"></div>
    <button id="btn-format">Format</button>
    <div class="toolbar-separator"></div>
    <button id="btn-wrap">Word Wrap: Off</button>
    <div class="toolbar-separator"></div>
    <button id="btn-theme">Light Theme</button>
  </div>

  <div id="main-container">
    <div id="files-panel">
      <div id="files-panel-header">Open Files</div>
      <div id="files-list"></div>
    </div>

    <div id="editor-container">
      <textarea id="editor"></textarea>
    </div>

    <div id="no-file-message" class="hidden">
      No file open. Click "New" or "Open" to get started.
    </div>
  </div>

  <div id="statusbar">
    <div class="left">
      <span id="status-text">Ready</span>
    </div>
    <div class="right">
      <span id="status-position">Ln 1, Col 1</span>
      <span id="status-encoding">UTF-8</span>
      <span id="status-language">Plain Text</span>
    </div>
  </div>

  <!-- Save confirmation modal -->
  <div id="save-modal" class="modal-overlay hidden">
    <div class="modal">
      <h3>Unsaved Changes</h3>
      <p id="save-modal-message">Do you want to save changes before closing?</p>
      <div class="modal-buttons">
        <button class="btn-secondary" id="modal-cancel">Cancel</button>
        <button class="btn-danger" id="modal-dont-save">Don't Save</button>
        <button class="btn-primary" id="modal-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Format selection modal -->
  <div id="format-modal" class="modal-overlay hidden">
    <div class="modal">
      <h3>Select Format Type</h3>
      <p id="format-modal-message">Choose a format type for this file:</p>
      <div class="format-modal-field">
        <select id="format-type-select">
          <option value="json">JSON</option>
          <option value="xml">XML</option>
          <option value="html">HTML</option>
        </select>
      </div>
      <div class="format-modal-field">
        <label id="format-remember-label">
          <input type="checkbox" id="format-remember-checkbox">
          <span id="format-remember-text">Always use this format for this extension</span>
        </label>
      </div>
      <div class="modal-buttons">
        <button class="btn-secondary" id="format-modal-cancel">Cancel</button>
        <button class="btn-primary" id="format-modal-apply">Format</button>
      </div>
    </div>
  </div>

  <!-- Close app confirmation modal -->
  <div id="close-app-modal" class="modal-overlay hidden">
    <div class="modal">
      <h3>Unsaved Changes</h3>
      <p id="close-app-modal-message">You have unsaved files. Close without saving?</p>
      <div class="modal-buttons">
        <button class="btn-secondary" id="close-app-cancel">Cancel</button>
        <button class="btn-danger" id="close-app-confirm">Close Without Saving</button>
      </div>
    </div>
  </div>

  <script>
    const { ipcRenderer, webUtils } = require('electron');
    const path = require('path');
    const CodeMirror = require('codemirror');

    // Load language modes
    require('codemirror/mode/javascript/javascript');
    require('codemirror/mode/xml/xml');
    require('codemirror/mode/htmlmixed/htmlmixed');
    require('codemirror/mode/css/css');
    require('codemirror/mode/clike/clike');
    require('codemirror/mode/python/python');
    require('codemirror/mode/sql/sql');
    require('codemirror/mode/markdown/markdown');
    require('codemirror/mode/yaml/yaml');

    // Load editor addons
    require('codemirror/addon/edit/closebrackets');
    require('codemirror/addon/edit/matchbrackets');
    require('codemirror/addon/edit/closetag');

    // State - multiple files support
    let openFiles = []; // Array of { id, filePath, content, encoding, language, isDirty }
    let activeFileId = null;
    let fileIdCounter = 0;
    let pendingCloseAction = null; // { type: 'close' | 'closeAll', fileId }
    let isLoadingContent = false; // Flag to suppress dirty marking during programmatic content changes
    let isDarkTheme = true; // Theme state
    let formatMappings = {}; // Extension-to-format mappings (e.g. { ".csproj": "xml" })

    // Initialize CodeMirror
    const editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
      lineNumbers: true,
      theme: 'material-darker',
      mode: 'text/plain',
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: true,
      lineWrapping: false,
      autoCloseBrackets: true,
      matchBrackets: true,
      autoCloseTags: true
    });

    // Track changes
    editor.on('change', () => {
      if (isLoadingContent) return; // Skip during programmatic content loading
      const file = getActiveFile();
      if (file && !file.isDirty) {
        file.isDirty = true;
        updateFilesList();
        updateTitle();
      }
    });

    // Track cursor position
    editor.on('cursorActivity', () => {
      const pos = editor.getCursor();
      updatePosition(pos.line + 1, pos.ch + 1);
    });

    // Button event listeners
    document.getElementById('btn-new').addEventListener('click', newFile);
    document.getElementById('btn-open').addEventListener('click', openFile);
    document.getElementById('btn-save').addEventListener('click', saveFile);
    document.getElementById('btn-save-as').addEventListener('click', saveFileAs);
    document.getElementById('btn-reload').addEventListener('click', reloadFile);
    document.getElementById('btn-close').addEventListener('click', () => closeFile(activeFileId));
    document.getElementById('btn-format').addEventListener('click', formatDocument);
    document.getElementById('btn-wrap').addEventListener('click', toggleWordWrap);
    document.getElementById('btn-theme').addEventListener('click', toggleTheme);

    // Modal buttons
    document.getElementById('modal-cancel').addEventListener('click', () => {
      hideModal();
      pendingCloseAction = null;
    });
    document.getElementById('modal-dont-save').addEventListener('click', () => {
      hideModal();
      if (pendingCloseAction) {
        forceCloseFile(pendingCloseAction.fileId);
        pendingCloseAction = null;
      }
    });
    document.getElementById('modal-save').addEventListener('click', async () => {
      hideModal();
      if (pendingCloseAction) {
        const fileId = pendingCloseAction.fileId;
        pendingCloseAction = null;
        await saveFileById(fileId);
        forceCloseFile(fileId);
      }
    });

    // Format modal buttons
    document.getElementById('format-modal-cancel').addEventListener('click', () => {
      document.getElementById('format-modal').classList.add('hidden');
    });
    document.getElementById('format-modal-apply').addEventListener('click', async () => {
      const formatType = document.getElementById('format-type-select').value;
      const remember = document.getElementById('format-remember-checkbox').checked;
      document.getElementById('format-modal').classList.add('hidden');

      const file = getActiveFile();
      if (!file) return;

      if (remember && file.filePath) {
        const ext = path.extname(file.filePath).toLowerCase();
        formatMappings[ext] = formatType;
        await ipcRenderer.invoke('save-format-mappings', formatMappings);
      }

      applyFormat(formatType);
    });

    // Close app modal buttons
    document.getElementById('close-app-cancel').addEventListener('click', () => {
      document.getElementById('close-app-modal').classList.add('hidden');
    });
    document.getElementById('close-app-confirm').addEventListener('click', () => {
      document.getElementById('close-app-modal').classList.add('hidden');
      ipcRenderer.send('confirm-close');
    });

    // Load saved format mappings on startup
    ipcRenderer.invoke('load-format-mappings').then(mappings => {
      formatMappings = mappings || {};
    });

    // IPC listeners
    ipcRenderer.on('menu-new', () => newFile());
    ipcRenderer.on('menu-save', () => saveFile());
    ipcRenderer.on('menu-save-as', () => saveFileAs());
    ipcRenderer.on('file-opened', (_, data) => loadFile(data));
    ipcRenderer.on('app-closing', () => {
      const hasUnsaved = openFiles.some(f => f.isDirty);
      if (hasUnsaved) {
        const unsavedCount = openFiles.filter(f => f.isDirty).length;
        const msg = unsavedCount === 1
          ? 'You have 1 unsaved file. Close without saving?'
          : `You have ${unsavedCount} unsaved files. Close without saving?`;
        document.getElementById('close-app-modal-message').textContent = msg;
        document.getElementById('close-app-modal').classList.remove('hidden');
      } else {
        ipcRenderer.send('confirm-close');
      }
    });

    function generateFileId() {
      return ++fileIdCounter;
    }

    function getActiveFile() {
      return openFiles.find(f => f.id === activeFileId);
    }

    function getFileById(id) {
      return openFiles.find(f => f.id === id);
    }

    function newFile() {
      const id = generateFileId();
      const file = {
        id,
        filePath: null,
        content: '',
        encoding: 'utf-8',
        language: 'plaintext',
        isDirty: false
      };
      openFiles.push(file);
      switchToFile(id);
      updateStatus('New file created');
    }

    async function openFile() {
      await ipcRenderer.invoke('open-file-dialog');
    }

    function loadFile(data) {
      // Check if file is already open
      const existingFile = openFiles.find(f => f.filePath === data.filePath);
      if (existingFile) {
        switchToFile(existingFile.id);
        updateStatus('File already open');
        return;
      }

      const id = generateFileId();
      const file = {
        id,
        filePath: data.filePath,
        content: data.content,
        encoding: data.encoding,
        language: data.language,
        isDirty: false
      };
      openFiles.push(file);
      switchToFile(id);
      updateStatus('Opened: ' + path.basename(data.filePath));
    }

    function switchToFile(id) {
      // Save current file content
      const currentFile = getActiveFile();
      if (currentFile) {
        currentFile.content = editor.getValue();
      }

      activeFileId = id;
      const file = getFileById(id);

      if (file) {
        isLoadingContent = true;
        editor.setValue(file.content);
        isLoadingContent = false;
        const mode = getCodeMirrorMode(file.language);
        editor.setOption('mode', mode);

        document.getElementById('editor-container').classList.remove('hidden');
        document.getElementById('no-file-message').classList.add('hidden');
        editor.refresh();

        updateTitle();
        updateEncoding(file.encoding.toUpperCase());
        updateLanguage(getLanguageDisplayName(file.language));
      }

      updateFilesList();
      editor.focus();
    }

    async function saveFile() {
      const file = getActiveFile();
      if (!file) return;

      file.content = editor.getValue();

      if (!file.filePath) {
        await saveFileAs();
        return;
      }

      const result = await ipcRenderer.invoke('save-file', {
        filePath: file.filePath,
        content: file.content,
        encoding: file.encoding
      });

      if (result.success) {
        file.isDirty = false;
        updateFilesList();
        updateTitle();
        updateStatus('File saved');
      } else {
        updateStatus('Error: ' + result.error);
      }
    }

    async function saveFileById(id) {
      const file = getFileById(id);
      if (!file) return;

      // If this is the active file, get latest content
      if (id === activeFileId) {
        file.content = editor.getValue();
      }

      if (!file.filePath) {
        // Switch to file first for save dialog
        switchToFile(id);
        await saveFileAs();
        return;
      }

      const result = await ipcRenderer.invoke('save-file', {
        filePath: file.filePath,
        content: file.content,
        encoding: file.encoding
      });

      if (result.success) {
        file.isDirty = false;
        updateFilesList();
        updateTitle();
        updateStatus('File saved');
      } else {
        updateStatus('Error: ' + result.error);
      }
    }

    async function saveFileAs() {
      const file = getActiveFile();
      if (!file) return;

      file.content = editor.getValue();
      const suggestedName = file.filePath ? path.basename(file.filePath) : 'untitled.txt';

      const result = await ipcRenderer.invoke('save-file-dialog', {
        content: file.content,
        encoding: file.encoding,
        suggestedName
      });

      if (result.success) {
        file.filePath = result.filePath;
        file.isDirty = false;
        file.language = getLanguageFromPath(result.filePath);
        const mode = getCodeMirrorMode(file.language);
        editor.setOption('mode', mode);
        updateFilesList();
        updateTitle();
        updateLanguage(getLanguageDisplayName(file.language));
        updateStatus('File saved');
      } else if (!result.canceled) {
        updateStatus('Error: ' + result.error);
      }
    }

    async function reloadFile() {
      const file = getActiveFile();
      if (!file || !file.filePath) {
        updateStatus('Cannot reload: No file path');
        return;
      }

      if (file.isDirty) {
        const confirmed = confirm('Discard unsaved changes and reload from disk?');
        if (!confirmed) return;
      }

      try {
        const data = await ipcRenderer.invoke('reload-file', { filePath: file.filePath });
        if (data) {
          file.content = data.content;
          file.encoding = data.encoding;
          file.isDirty = false;
          isLoadingContent = true;
          editor.setValue(file.content);
          isLoadingContent = false;
          updateFilesList();
          updateTitle();
          updateEncoding(file.encoding.toUpperCase());
          updateStatus('File reloaded');
        }
      } catch (err) {
        updateStatus('Error reloading file');
      }
    }

    function closeFile(id) {
      const file = getFileById(id);
      if (!file) return;

      if (file.isDirty) {
        pendingCloseAction = { type: 'close', fileId: id };
        const fileName = file.filePath ? path.basename(file.filePath) : 'Untitled';
        document.getElementById('save-modal-message').textContent =
          `Do you want to save changes to "${fileName}" before closing?`;
        showModal();
      } else {
        forceCloseFile(id);
      }
    }

    function forceCloseFile(id) {
      const index = openFiles.findIndex(f => f.id === id);
      if (index === -1) return;

      openFiles.splice(index, 1);

      if (openFiles.length === 0) {
        activeFileId = null;
        editor.setValue('');
        document.getElementById('editor-container').classList.add('hidden');
        document.getElementById('no-file-message').classList.remove('hidden');
        updateTitle();
        updateStatus('Ready');
      } else if (activeFileId === id) {
        // Switch to another file
        const newIndex = Math.min(index, openFiles.length - 1);
        switchToFile(openFiles[newIndex].id);
      }

      updateFilesList();
    }

    function showModal() {
      document.getElementById('save-modal').classList.remove('hidden');
    }

    function hideModal() {
      document.getElementById('save-modal').classList.add('hidden');
    }

    function toggleWordWrap() {
      const current = editor.getOption('lineWrapping');
      editor.setOption('lineWrapping', !current);
      document.getElementById('btn-wrap').textContent = !current ? 'Word Wrap: On' : 'Word Wrap: Off';
    }

    function toggleTheme() {
      isDarkTheme = !isDarkTheme;
      const btn = document.getElementById('btn-theme');

      if (isDarkTheme) {
        document.body.classList.remove('light-theme');
        editor.setOption('theme', 'material-darker');
        btn.textContent = 'Light Theme';
      } else {
        document.body.classList.add('light-theme');
        editor.setOption('theme', 'default');
        btn.textContent = 'Dark Theme';
      }
    }

    function getFormatType(file) {
      const supportedFormats = ['json', 'xml', 'html'];
      if (supportedFormats.includes(file.language)) {
        return file.language;
      }
      if (file.filePath) {
        const ext = path.extname(file.filePath).toLowerCase();
        if (formatMappings[ext]) {
          return formatMappings[ext];
        }
      }
      return null;
    }

    function applyFormat(formatType) {
      const file = getActiveFile();
      if (!file) return;

      // Apply syntax highlighting for the selected format type
      file.language = formatType;
      editor.setOption('mode', getCodeMirrorMode(formatType));
      updateLanguage(getLanguageDisplayName(formatType));

      const content = editor.getValue();
      let formatted;

      try {
        if (formatType === 'json') {
          formatted = formatJSON(content);
        } else if (formatType === 'xml') {
          formatted = formatXML(content);
        } else if (formatType === 'html') {
          formatted = formatHTML(content);
        } else {
          updateStatus('Unknown format type: ' + formatType);
          return;
        }

        if (formatted !== null && formatted !== content) {
          isLoadingContent = true;
          editor.setValue(formatted);
          isLoadingContent = false;
          file.isDirty = true;
          updateFilesList();
          updateTitle();
          updateStatus('Document formatted as ' + formatType.toUpperCase());
        } else {
          updateStatus('Document highlighted as ' + formatType.toUpperCase());
        }
      } catch (err) {
        updateStatus('Format error: ' + err.message);
      }
    }

    function showFormatModal(file) {
      const ext = file.filePath ? path.extname(file.filePath).toLowerCase() : '';
      const msg = ext
        ? 'Choose a format type for ' + ext + ' files:'
        : 'Choose a format type:';
      document.getElementById('format-modal-message').textContent = msg;

      const rememberLabel = document.getElementById('format-remember-label');
      if (ext) {
        rememberLabel.classList.remove('hidden');
        document.getElementById('format-remember-text').textContent =
          'Always use this format for ' + ext + ' files';
      } else {
        rememberLabel.classList.add('hidden');
      }

      document.getElementById('format-remember-checkbox').checked = false;
      document.getElementById('format-type-select').value = 'xml';
      document.getElementById('format-modal').classList.remove('hidden');
    }

    function formatDocument() {
      const file = getActiveFile();
      if (!file) {
        updateStatus('No file open');
        return;
      }

      const formatType = getFormatType(file);
      if (formatType) {
        applyFormat(formatType);
      } else {
        showFormatModal(file);
      }
    }

    function formatJSON(content) {
      const parsed = JSON.parse(content);
      return JSON.stringify(parsed, null, 2);
    }

    function formatXML(content) {
      const PADDING = '  ';
      let formatted = '';
      let indent = 0;

      // Remove existing whitespace between tags
      const xml = content.replace(/>\s*</g, '><').trim();

      xml.split(/(<[^>]+>)/g).forEach(node => {
        if (!node.trim()) return;

        if (node.match(/^<\?/)) {
          // XML declaration
          formatted += node + '\n';
        } else if (node.match(/^<\//)) {
          // Closing tag
          indent--;
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^<[^/].*[^/]>$/)) {
          // Opening tag (not self-closing)
          formatted += PADDING.repeat(indent) + node + '\n';
          indent++;
        } else if (node.match(/^<.*\/>$/)) {
          // Self-closing tag
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^</)) {
          // Other tags
          formatted += PADDING.repeat(indent) + node + '\n';
        } else {
          // Text content
          if (node.trim()) {
            formatted += PADDING.repeat(indent) + node.trim() + '\n';
          }
        }
      });

      return formatted.trim();
    }

    function formatHTML(content) {
      const PADDING = '  ';
      let formatted = '';
      let indent = 0;

      // Inline elements that shouldn't force newlines
      const inlineElements = ['a', 'span', 'strong', 'em', 'b', 'i', 'u', 'small', 'code', 'br', 'img'];
      // Void elements (self-closing)
      const voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

      // Remove existing whitespace between tags
      const html = content.replace(/>\s+</g, '><').trim();

      html.split(/(<[^>]+>)/g).forEach(node => {
        if (!node.trim()) return;

        const tagMatch = node.match(/^<\/?(\w+)/);
        const tagName = tagMatch ? tagMatch[1].toLowerCase() : '';

        if (node.match(/^<!DOCTYPE/i)) {
          // DOCTYPE
          formatted += node + '\n';
        } else if (node.match(/^<!--/)) {
          // Comment
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^<\//)) {
          // Closing tag
          indent = Math.max(0, indent - 1);
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^<[^/]/) && !voidElements.includes(tagName)) {
          // Opening tag (not void)
          formatted += PADDING.repeat(indent) + node + '\n';
          indent++;
        } else if (node.match(/^</)) {
          // Void/self-closing tag
          formatted += PADDING.repeat(indent) + node + '\n';
        } else {
          // Text content
          if (node.trim()) {
            formatted += PADDING.repeat(indent) + node.trim() + '\n';
          }
        }
      });

      return formatted.trim();
    }

    function updateTitle() {
      const file = getActiveFile();
      if (file) {
        const fileName = file.filePath ? path.basename(file.filePath) : 'Untitled';
        document.title = (file.isDirty ? '* ' : '') + fileName + ' - Text Editor';
      } else {
        document.title = 'Text Editor';
      }
    }

    function updateStatus(text) {
      document.getElementById('status-text').textContent = text;
    }

    function updatePosition(line, col) {
      document.getElementById('status-position').textContent = 'Ln ' + line + ', Col ' + col;
    }

    function updateEncoding(encoding) {
      document.getElementById('status-encoding').textContent = encoding;
    }

    function updateLanguage(language) {
      document.getElementById('status-language').textContent = language;
    }

    function updateFilesList() {
      const container = document.getElementById('files-list');
      container.innerHTML = '';

      openFiles.forEach(file => {
        const div = document.createElement('div');
        div.className = 'file-item' +
          (file.id === activeFileId ? ' active' : '') +
          (file.isDirty ? ' modified' : '');

        const nameSpan = document.createElement('span');
        nameSpan.className = 'file-name';
        nameSpan.textContent = file.filePath ? path.basename(file.filePath) : 'Untitled';
        nameSpan.title = file.filePath || 'Untitled';

        div.appendChild(nameSpan);

        // Only show close button for non-modified files
        if (!file.isDirty) {
          const closeBtn = document.createElement('span');
          closeBtn.className = 'file-close';
          closeBtn.textContent = '×';
          closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeFile(file.id);
          });
          div.appendChild(closeBtn);
        }

        div.addEventListener('click', () => switchToFile(file.id));
        container.appendChild(div);
      });
    }

    function getCodeMirrorMode(language) {
      const modes = {
        'html': 'htmlmixed',
        'xml': 'xml',
        'json': { name: 'javascript', json: true },
        'javascript': 'javascript',
        'typescript': { name: 'javascript', typescript: true },
        'css': 'css',
        'scss': 'text/x-scss',
        'less': 'text/x-less',
        'csharp': 'text/x-csharp',
        'c': 'text/x-csrc',
        'cpp': 'text/x-c++src',
        'java': 'text/x-java',
        'python': 'python',
        'sql': 'sql',
        'markdown': 'markdown',
        'yaml': 'yaml',
        'plaintext': 'text/plain'
      };
      return modes[language] || 'text/plain';
    }

    function getLanguageDisplayName(lang) {
      const names = {
        'plaintext': 'Plain Text',
        'html': 'HTML',
        'xml': 'XML',
        'json': 'JSON',
        'javascript': 'JavaScript',
        'typescript': 'TypeScript',
        'csharp': 'C#',
        'css': 'CSS',
        'scss': 'SCSS',
        'less': 'Less',
        'java': 'Java',
        'sql': 'SQL',
        'c': 'C',
        'cpp': 'C++',
        'python': 'Python',
        'markdown': 'Markdown',
        'yaml': 'YAML'
      };
      return names[lang] || lang;
    }

    function getLanguageFromPath(filePath) {
      const ext = path.extname(filePath).toLowerCase();
      const map = {
        '.html': 'html',
        '.htm': 'html',
        '.xml': 'xml',
        '.xaml': 'xml',
        '.json': 'json',
        '.js': 'javascript',
        '.jsx': 'javascript',
        '.mjs': 'javascript',
        '.ts': 'typescript',
        '.tsx': 'typescript',
        '.cs': 'csharp',
        '.css': 'css',
        '.scss': 'scss',
        '.less': 'less',
        '.java': 'java',
        '.sql': 'sql',
        '.c': 'c',
        '.h': 'c',
        '.cpp': 'cpp',
        '.hpp': 'cpp',
        '.py': 'python',
        '.md': 'markdown',
        '.yaml': 'yaml',
        '.yml': 'yaml',
        '.txt': 'plaintext'
      };
      return map[ext] || 'plaintext';
    }

    // Drag and drop file opening (capture phase to intercept before CodeMirror)
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, true);
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      const file = e.dataTransfer.files[0];
      if (!file) return;
      const filePath = webUtils.getPathForFile(file);
      if (!filePath) return;
      const data = await ipcRenderer.invoke('reload-file', { filePath });
      if (data) {
        loadFile(data);
        ipcRenderer.send('add-recent-file', filePath);
      }
    }, true);

    // Initialize - show no file message
    document.getElementById('editor-container').classList.add('hidden');
    document.getElementById('no-file-message').classList.remove('hidden');
    updateTitle();
  </script>
</body>
</html>
