<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Editor</title>
  <link rel="stylesheet" href="../node_modules/codemirror/lib/codemirror.css">
  <link rel="stylesheet" href="../node_modules/codemirror/theme/material-darker.css">
  <link rel="stylesheet" href="../node_modules/codemirror/theme/monokai.css">
  <link rel="stylesheet" href="../node_modules/codemirror/theme/dracula.css">
  <link rel="stylesheet" href="../node_modules/codemirror/theme/solarized.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background-color: #1e1e1e;
      color: #d4d4d4;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #toolbar {
      display: flex;
      gap: 8px;
      padding: 8px;
      background-color: #2d2d2d;
      border-bottom: 1px solid #404040;
    }

    #toolbar button {
      padding: 6px 10px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      min-width: 32px;
      text-align: center;
      position: relative;
    }

    #toolbar button.active {
      background-color: #007acc;
      border-color: #007acc;
    }

    #toolbar button:hover {
      background-color: #4c4c4c;
    }

    #toolbar button::after {
      content: attr(data-tooltip);
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 6px;
      padding: 4px 8px;
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      z-index: 100;
    }

    #toolbar button:hover::after {
      opacity: 1;
    }

    #toolbar select {
      padding: 6px 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    .toolbar-separator {
      width: 1px;
      background-color: #505050;
      margin: 0 4px;
    }

    #main-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    #files-panel {
      width: 200px;
      background-color: #252526;
      border-right: 1px solid #404040;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #files-panel-header {
      padding: 8px 12px;
      font-size: 11px;
      text-transform: uppercase;
      color: #888;
      border-bottom: 1px solid #404040;
    }

    #files-list {
      flex: 1;
      overflow-y: auto;
    }

    .file-item {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      border-left: 3px solid transparent;
    }

    .file-item:hover {
      background-color: #2a2d2e;
    }

    .file-item.active {
      background-color: #37373d;
      border-left-color: #007acc;
    }

    .file-item.modified {
      color: #e57373;
    }

    .file-item.modified .file-name::after {
      content: ' •';
    }

    .file-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-close {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      opacity: 0;
      font-size: 14px;
      color: #888;
    }

    .file-item:hover .file-close {
      opacity: 1;
    }

    .file-close:hover {
      background-color: #404040;
      color: #fff;
    }

    .file-item.modified .file-close {
      display: none;
    }

    #editor-container {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    #btn-close {
      margin-left: auto;
      padding: 6px 10px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
    }

    #btn-close:hover {
      background-color: #d32f2f;
      color: white;
    }

    .CodeMirror {
      height: 100%;
      font-family: 'Cascadia Code', 'Fira Code', Consolas, 'Courier New', monospace;
      font-size: 14px;
    }

    .CodeMirror-selected {
      background-color: #264f78 !important;
    }

    .CodeMirror-focused .CodeMirror-selected {
      background-color: #264f78 !important;
    }

    #statusbar {
      display: flex;
      justify-content: space-between;
      padding: 4px 12px;
      background-color: #007acc;
      color: white;
      font-size: 12px;
    }

    #statusbar .left {
      display: flex;
      gap: 20px;
    }

    #statusbar .right {
      display: flex;
      gap: 20px;
    }

    #no-file-message {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-size: 16px;
    }

    /* Modal styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal {
      background-color: #2d2d2d;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      min-width: 300px;
      max-width: 400px;
    }

    .modal h3 {
      margin-bottom: 12px;
      color: #d4d4d4;
    }

    .modal p {
      margin-bottom: 20px;
      color: #999;
    }

    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .modal-buttons button {
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    .modal-buttons .btn-primary {
      background-color: #007acc;
      color: white;
      border: none;
    }

    .modal-buttons .btn-secondary {
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
    }

    .modal-buttons .btn-danger {
      background-color: #d32f2f;
      color: white;
      border: none;
    }

    .format-modal-field {
      margin-bottom: 16px;
    }

    .format-modal-field select {
      width: 100%;
      padding: 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      font-size: 13px;
    }

    .format-modal-field label {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #d4d4d4;
      font-size: 13px;
      cursor: pointer;
    }

    .format-modal-field input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    /* Search panel */
    #search-panel {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background-color: #252526;
      border-bottom: 1px solid #404040;
    }

    #search-panel input[type="text"] {
      padding: 4px 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      font-size: 13px;
      width: 180px;
      outline: none;
    }

    #search-panel input[type="text"]:focus {
      border-color: #007acc;
    }

    #search-panel button {
      padding: 4px 8px;
      background-color: #3c3c3c;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      line-height: 1;
      position: relative;
    }

    #search-panel button:hover {
      background-color: #4c4c4c;
    }

    #search-panel button::after {
      content: attr(data-tooltip);
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 6px;
      padding: 4px 8px;
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: 1px solid #505050;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      z-index: 100;
    }

    #search-panel button:hover::after {
      opacity: 1;
    }

    #search-panel label {
      display: flex;
      align-items: center;
      gap: 3px;
      color: #d4d4d4;
      font-size: 12px;
      cursor: pointer;
    }

    #search-panel input[type="checkbox"] {
      cursor: pointer;
    }

    #search-count {
      color: #888;
      font-size: 12px;
      margin-left: auto;
      white-space: nowrap;
    }

    #btn-search-close:hover {
      background-color: #d32f2f !important;
      color: white;
    }

    .search-highlight {
      background-color: rgba(255, 215, 0, 0.3);
    }

    .search-highlight-current {
      background-color: rgba(255, 165, 0, 0.6);
    }

    .hidden {
      display: none !important;
    }

    /* Light theme styles */
    body.light-theme {
      background-color: #ffffff;
      color: #333333;
    }

    body.light-theme #toolbar {
      background-color: #f0f0f0;
      border-bottom-color: #cccccc;
    }

    body.light-theme #toolbar button {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #toolbar select {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #toolbar button:hover {
      background-color: #d0d0d0;
    }

    body.light-theme .toolbar-separator {
      background-color: #cccccc;
    }

    body.light-theme #files-panel {
      background-color: #f5f5f5;
      border-right-color: #cccccc;
    }

    body.light-theme #files-panel-header {
      color: #666666;
      border-bottom-color: #cccccc;
    }

    body.light-theme .file-item:hover {
      background-color: #e8e8e8;
    }

    body.light-theme .file-item.active {
      background-color: #e0e0e0;
    }

    body.light-theme .file-item.modified {
      color: #c62828;
    }

    body.light-theme .file-close {
      color: #666666;
    }

    body.light-theme .file-close:hover {
      background-color: #d0d0d0;
      color: #333333;
    }

    body.light-theme #no-file-message {
      color: #999999;
    }

    body.light-theme .modal {
      background-color: #ffffff;
      border-color: #cccccc;
    }

    body.light-theme .modal h3 {
      color: #333333;
    }

    body.light-theme .modal p {
      color: #666666;
    }

    body.light-theme .modal-buttons .btn-secondary {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme .format-modal-field select {
      background-color: #ffffff;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme .format-modal-field label {
      color: #333333;
    }

    body.light-theme #search-panel {
      background-color: #f0f0f0;
      border-bottom-color: #cccccc;
    }

    body.light-theme #search-panel input[type="text"] {
      background-color: #ffffff;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #search-panel button {
      background-color: #e0e0e0;
      color: #333333;
      border-color: #cccccc;
    }

    body.light-theme #search-panel button:hover {
      background-color: #d0d0d0;
    }

    body.light-theme #search-panel label {
      color: #333333;
    }

    body.light-theme #search-count {
      color: #666666;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="btn-new" data-tooltip="New file">&#x1F4C4;</button>
    <button id="btn-open" data-tooltip="Open file">&#x1F4C2;</button>
    <button id="btn-save" data-tooltip="Save">&#x1F4BE;</button>
    <button id="btn-save-as" data-tooltip="Save As">&#x1F4E5;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-reload" data-tooltip="Reload from disk">&#x21BB;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-format" data-tooltip="Format document">&#x2261;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-wrap" data-tooltip="Toggle word wrap">&#x21A9;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-search" data-tooltip="Find and Replace">&#x1F50D;</button>
    <div class="toolbar-separator"></div>
    <select id="theme-select">
      <option value="dark">Dark</option>
      <option value="light">Light</option>
      <option value="monokai">Monokai</option>
      <option value="dracula">Dracula</option>
      <option value="solarized-light">Solarized Light</option>
    </select>
    <button id="btn-close" data-tooltip="Close file">&#x2715;</button>
  </div>

  <div id="search-panel" class="hidden">
    <input type="text" id="search-input" placeholder="Find">
    <input type="text" id="replace-input" placeholder="Replace">
    <button id="btn-search-prev" data-tooltip="Previous match">&#x25B2;</button>
    <button id="btn-search-next" data-tooltip="Next match">&#x25BC;</button>
    <button id="btn-replace" data-tooltip="Replace">Replace</button>
    <button id="btn-replace-all" data-tooltip="Replace all">All</button>
    <label data-tooltip="Case sensitive"><input type="checkbox" id="search-case"> Aa</label>
    <label data-tooltip="Regular expression"><input type="checkbox" id="search-regex"> .*</label>
    <span id="search-count">No results</span>
    <button id="btn-search-close" data-tooltip="Close search">&#x2715;</button>
  </div>

  <div id="main-container">
    <div id="files-panel">
      <div id="files-panel-header">Open Files</div>
      <div id="files-list"></div>
    </div>

    <div id="editor-container">
      <textarea id="editor"></textarea>
    </div>

    <div id="no-file-message" class="hidden">
      No file open. Click "New" or "Open" to get started.
    </div>
  </div>

  <div id="statusbar">
    <div class="left">
      <span id="status-text">Ready</span>
    </div>
    <div class="right">
      <span id="status-position">Ln 1, Col 1</span>
      <span id="status-encoding">UTF-8</span>
      <span id="status-language">Plain Text</span>
    </div>
  </div>

  <!-- Save confirmation modal -->
  <div id="save-modal" class="modal-overlay hidden">
    <div class="modal">
      <h3>Unsaved Changes</h3>
      <p id="save-modal-message">Do you want to save changes before closing?</p>
      <div class="modal-buttons">
        <button class="btn-secondary" id="modal-cancel">Cancel</button>
        <button class="btn-danger" id="modal-dont-save">Don't Save</button>
        <button class="btn-primary" id="modal-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Format selection modal -->
  <div id="format-modal" class="modal-overlay hidden">
    <div class="modal">
      <h3>Select Format Type</h3>
      <p id="format-modal-message">Choose a format type for this file:</p>
      <div class="format-modal-field">
        <select id="format-type-select">
          <option value="json">JSON</option>
          <option value="xml">XML</option>
          <option value="html">HTML</option>
        </select>
      </div>
      <div class="format-modal-field">
        <label id="format-remember-label">
          <input type="checkbox" id="format-remember-checkbox">
          <span id="format-remember-text">Always use this format for this extension</span>
        </label>
      </div>
      <div class="modal-buttons">
        <button class="btn-secondary" id="format-modal-cancel">Cancel</button>
        <button class="btn-primary" id="format-modal-apply">Format</button>
      </div>
    </div>
  </div>

  <!-- Close app confirmation modal -->
  <div id="close-app-modal" class="modal-overlay hidden">
    <div class="modal">
      <h3>Unsaved Changes</h3>
      <p id="close-app-modal-message">You have unsaved files. Close without saving?</p>
      <div class="modal-buttons">
        <button class="btn-secondary" id="close-app-cancel">Cancel</button>
        <button class="btn-danger" id="close-app-confirm">Close Without Saving</button>
      </div>
    </div>
  </div>

  <script>
    const { ipcRenderer, webUtils } = require('electron');
    const path = require('path');
    const CodeMirror = require('codemirror');

    // Load language modes
    require('codemirror/mode/javascript/javascript');
    require('codemirror/mode/xml/xml');
    require('codemirror/mode/htmlmixed/htmlmixed');
    require('codemirror/mode/css/css');
    require('codemirror/mode/clike/clike');
    require('codemirror/mode/python/python');
    require('codemirror/mode/sql/sql');
    require('codemirror/mode/markdown/markdown');
    require('codemirror/mode/yaml/yaml');

    // Load editor addons
    require('codemirror/addon/edit/closebrackets');
    require('codemirror/addon/edit/matchbrackets');
    require('codemirror/addon/edit/closetag');
    require('codemirror/addon/search/searchcursor');

    // State - multiple files support
    let openFiles = []; // Array of { id, filePath, content, encoding, language, isDirty }
    let activeFileId = null;
    let fileIdCounter = 0;
    let pendingCloseAction = null; // { type: 'close' | 'closeAll', fileId }
    let isLoadingContent = false; // Flag to suppress dirty marking during programmatic content changes
    let currentTheme = 'dark'; // Theme state
    let formatMappings = {}; // Extension-to-format mappings (e.g. { ".csproj": "xml" })

    // Initialize CodeMirror
    const editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
      lineNumbers: true,
      theme: 'material-darker',
      mode: 'text/plain',
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: true,
      lineWrapping: false,
      autoCloseBrackets: true,
      matchBrackets: true,
      autoCloseTags: true
    });

    // Track changes
    editor.on('change', () => {
      if (isLoadingContent) return; // Skip during programmatic content loading
      const file = getActiveFile();
      if (file && !file.isDirty) {
        file.isDirty = true;
        updateFilesList();
        updateTitle();
      }
    });

    // Track cursor position
    editor.on('cursorActivity', () => {
      const pos = editor.getCursor();
      updatePosition(pos.line + 1, pos.ch + 1);
    });

    // Button event listeners
    document.getElementById('btn-new').addEventListener('click', newFile);
    document.getElementById('btn-open').addEventListener('click', openFile);
    document.getElementById('btn-save').addEventListener('click', saveFile);
    document.getElementById('btn-save-as').addEventListener('click', saveFileAs);
    document.getElementById('btn-reload').addEventListener('click', reloadFile);
    document.getElementById('btn-close').addEventListener('click', () => closeFile(activeFileId));
    document.getElementById('btn-format').addEventListener('click', formatDocument);
    document.getElementById('btn-wrap').addEventListener('click', toggleWordWrap);
    document.getElementById('btn-search').addEventListener('click', toggleSearchPanel);
    document.getElementById('btn-search-prev').addEventListener('click', () => navigateMatch(-1));
    document.getElementById('btn-search-next').addEventListener('click', () => navigateMatch(1));
    document.getElementById('btn-replace').addEventListener('click', replaceCurrent);
    document.getElementById('btn-replace-all').addEventListener('click', replaceAll);
    document.getElementById('btn-search-close').addEventListener('click', closeSearchPanel);

    document.getElementById('search-input').addEventListener('input', performSearch);
    document.getElementById('search-case').addEventListener('change', performSearch);
    document.getElementById('search-regex').addEventListener('change', performSearch);

    document.getElementById('search-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        navigateMatch(e.shiftKey ? -1 : 1);
      } else if (e.key === 'Escape') {
        closeSearchPanel();
      }
    });
    document.getElementById('replace-input').addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeSearchPanel();
      }
    });

    document.getElementById('theme-select').addEventListener('change', (e) => {
      applyTheme(e.target.value);
      ipcRenderer.invoke('save-preference', { key: 'theme', value: e.target.value });
    });

    // Modal buttons
    document.getElementById('modal-cancel').addEventListener('click', () => {
      hideModal();
      pendingCloseAction = null;
    });
    document.getElementById('modal-dont-save').addEventListener('click', () => {
      hideModal();
      if (pendingCloseAction) {
        forceCloseFile(pendingCloseAction.fileId);
        pendingCloseAction = null;
      }
    });
    document.getElementById('modal-save').addEventListener('click', async () => {
      hideModal();
      if (pendingCloseAction) {
        const fileId = pendingCloseAction.fileId;
        pendingCloseAction = null;
        await saveFileById(fileId);
        forceCloseFile(fileId);
      }
    });

    // Format modal buttons
    document.getElementById('format-modal-cancel').addEventListener('click', () => {
      document.getElementById('format-modal').classList.add('hidden');
    });
    document.getElementById('format-modal-apply').addEventListener('click', async () => {
      const formatType = document.getElementById('format-type-select').value;
      const remember = document.getElementById('format-remember-checkbox').checked;
      document.getElementById('format-modal').classList.add('hidden');

      const file = getActiveFile();
      if (!file) return;

      if (remember && file.filePath) {
        const ext = path.extname(file.filePath).toLowerCase();
        formatMappings[ext] = formatType;
        await ipcRenderer.invoke('save-format-mappings', formatMappings);
      }

      applyFormat(formatType);
    });

    // Close app modal buttons
    document.getElementById('close-app-cancel').addEventListener('click', () => {
      document.getElementById('close-app-modal').classList.add('hidden');
    });
    document.getElementById('close-app-confirm').addEventListener('click', () => {
      document.getElementById('close-app-modal').classList.add('hidden');
      ipcRenderer.send('confirm-close');
    });

    // Load saved format mappings on startup
    ipcRenderer.invoke('load-format-mappings').then(mappings => {
      formatMappings = mappings || {};
    });

    // Load saved preferences on startup
    ipcRenderer.invoke('load-preferences').then(prefs => {
      if (prefs && prefs.theme) {
        applyTheme(prefs.theme);
      }
    });

    // IPC listeners
    ipcRenderer.on('menu-new', () => newFile());
    ipcRenderer.on('menu-save', () => saveFile());
    ipcRenderer.on('menu-save-as', () => saveFileAs());
    ipcRenderer.on('file-opened', (_, data) => loadFile(data));
    ipcRenderer.on('app-closing', () => {
      const hasUnsaved = openFiles.some(f => f.isDirty);
      if (hasUnsaved) {
        const unsavedCount = openFiles.filter(f => f.isDirty).length;
        const msg = unsavedCount === 1
          ? 'You have 1 unsaved file. Close without saving?'
          : `You have ${unsavedCount} unsaved files. Close without saving?`;
        document.getElementById('close-app-modal-message').textContent = msg;
        document.getElementById('close-app-modal').classList.remove('hidden');
      } else {
        ipcRenderer.send('confirm-close');
      }
    });

    function generateFileId() {
      return ++fileIdCounter;
    }

    function getActiveFile() {
      return openFiles.find(f => f.id === activeFileId);
    }

    function getFileById(id) {
      return openFiles.find(f => f.id === id);
    }

    function newFile() {
      const id = generateFileId();
      const file = {
        id,
        filePath: null,
        content: '',
        encoding: 'utf-8',
        language: 'plaintext',
        isDirty: false
      };
      openFiles.push(file);
      switchToFile(id);
      updateStatus('New file created');
    }

    async function openFile() {
      await ipcRenderer.invoke('open-file-dialog');
    }

    function loadFile(data) {
      // Check if file is already open
      const existingFile = openFiles.find(f => f.filePath === data.filePath);
      if (existingFile) {
        switchToFile(existingFile.id);
        updateStatus('File already open');
        return;
      }

      const id = generateFileId();
      const file = {
        id,
        filePath: data.filePath,
        content: data.content,
        encoding: data.encoding,
        language: data.language,
        isDirty: false
      };
      openFiles.push(file);
      switchToFile(id);
      updateStatus('Opened: ' + path.basename(data.filePath));
    }

    function switchToFile(id) {
      // Save current file content
      const currentFile = getActiveFile();
      if (currentFile) {
        currentFile.content = editor.getValue();
      }

      activeFileId = id;
      const file = getFileById(id);

      if (file) {
        isLoadingContent = true;
        editor.setValue(file.content);
        isLoadingContent = false;
        const mode = getCodeMirrorMode(file.language);
        editor.setOption('mode', mode);

        document.getElementById('editor-container').classList.remove('hidden');
        document.getElementById('no-file-message').classList.add('hidden');
        editor.refresh();

        updateTitle();
        updateEncoding(file.encoding.toUpperCase());
        updateLanguage(getLanguageDisplayName(file.language));
      }

      updateFilesList();
      editor.focus();
    }

    async function saveFile() {
      const file = getActiveFile();
      if (!file) return;

      file.content = editor.getValue();

      if (!file.filePath) {
        await saveFileAs();
        return;
      }

      const result = await ipcRenderer.invoke('save-file', {
        filePath: file.filePath,
        content: file.content,
        encoding: file.encoding
      });

      if (result.success) {
        file.isDirty = false;
        updateFilesList();
        updateTitle();
        updateStatus('File saved');
      } else {
        updateStatus('Error: ' + result.error);
      }
    }

    async function saveFileById(id) {
      const file = getFileById(id);
      if (!file) return;

      // If this is the active file, get latest content
      if (id === activeFileId) {
        file.content = editor.getValue();
      }

      if (!file.filePath) {
        // Switch to file first for save dialog
        switchToFile(id);
        await saveFileAs();
        return;
      }

      const result = await ipcRenderer.invoke('save-file', {
        filePath: file.filePath,
        content: file.content,
        encoding: file.encoding
      });

      if (result.success) {
        file.isDirty = false;
        updateFilesList();
        updateTitle();
        updateStatus('File saved');
      } else {
        updateStatus('Error: ' + result.error);
      }
    }

    async function saveFileAs() {
      const file = getActiveFile();
      if (!file) return;

      file.content = editor.getValue();
      const suggestedName = file.filePath ? path.basename(file.filePath) : 'untitled.txt';

      const result = await ipcRenderer.invoke('save-file-dialog', {
        content: file.content,
        encoding: file.encoding,
        suggestedName
      });

      if (result.success) {
        file.filePath = result.filePath;
        file.isDirty = false;
        file.language = getLanguageFromPath(result.filePath);
        const mode = getCodeMirrorMode(file.language);
        editor.setOption('mode', mode);
        updateFilesList();
        updateTitle();
        updateLanguage(getLanguageDisplayName(file.language));
        updateStatus('File saved');
      } else if (!result.canceled) {
        updateStatus('Error: ' + result.error);
      }
    }

    async function reloadFile() {
      const file = getActiveFile();
      if (!file || !file.filePath) {
        updateStatus('Cannot reload: No file path');
        return;
      }

      if (file.isDirty) {
        const confirmed = confirm('Discard unsaved changes and reload from disk?');
        if (!confirmed) return;
      }

      try {
        const data = await ipcRenderer.invoke('reload-file', { filePath: file.filePath });
        if (data) {
          file.content = data.content;
          file.encoding = data.encoding;
          file.isDirty = false;
          isLoadingContent = true;
          editor.setValue(file.content);
          isLoadingContent = false;
          updateFilesList();
          updateTitle();
          updateEncoding(file.encoding.toUpperCase());
          updateStatus('File reloaded');
        }
      } catch (err) {
        updateStatus('Error reloading file');
      }
    }

    function closeFile(id) {
      const file = getFileById(id);
      if (!file) return;

      if (file.isDirty) {
        pendingCloseAction = { type: 'close', fileId: id };
        const fileName = file.filePath ? path.basename(file.filePath) : 'Untitled';
        document.getElementById('save-modal-message').textContent =
          `Do you want to save changes to "${fileName}" before closing?`;
        showModal();
      } else {
        forceCloseFile(id);
      }
    }

    function forceCloseFile(id) {
      const index = openFiles.findIndex(f => f.id === id);
      if (index === -1) return;

      openFiles.splice(index, 1);

      if (openFiles.length === 0) {
        activeFileId = null;
        editor.setValue('');
        document.getElementById('editor-container').classList.add('hidden');
        document.getElementById('no-file-message').classList.remove('hidden');
        updateTitle();
        updateStatus('Ready');
      } else if (activeFileId === id) {
        // Switch to another file
        const newIndex = Math.min(index, openFiles.length - 1);
        switchToFile(openFiles[newIndex].id);
      }

      updateFilesList();
    }

    function showModal() {
      document.getElementById('save-modal').classList.remove('hidden');
    }

    function hideModal() {
      document.getElementById('save-modal').classList.add('hidden');
    }

    function toggleWordWrap() {
      const current = editor.getOption('lineWrapping');
      editor.setOption('lineWrapping', !current);
      const btn = document.getElementById('btn-wrap');
      btn.classList.toggle('active', !current);
      btn.setAttribute('data-tooltip', !current ? 'Word wrap on' : 'Toggle word wrap');
    }

    const themeMap = {
      'dark': { cm: 'material-darker', bodyClass: '' },
      'light': { cm: 'default', bodyClass: 'light-theme' },
      'monokai': { cm: 'monokai', bodyClass: '' },
      'dracula': { cm: 'dracula', bodyClass: '' },
      'solarized-light': { cm: 'solarized light', bodyClass: 'light-theme' }
    };

    function applyTheme(themeName) {
      const theme = themeMap[themeName];
      if (!theme) return;
      currentTheme = themeName;

      // Remove all theme body classes, then apply if needed
      document.body.classList.remove('light-theme');
      if (theme.bodyClass) {
        document.body.classList.add(theme.bodyClass);
      }
      editor.setOption('theme', theme.cm);
      document.getElementById('theme-select').value = themeName;
    }

    function getFormatType(file) {
      const supportedFormats = ['json', 'xml', 'html'];
      if (supportedFormats.includes(file.language)) {
        return file.language;
      }
      if (file.filePath) {
        const ext = path.extname(file.filePath).toLowerCase();
        if (formatMappings[ext]) {
          return formatMappings[ext];
        }
      }
      return null;
    }

    function applyFormat(formatType) {
      const file = getActiveFile();
      if (!file) return;

      // Apply syntax highlighting for the selected format type
      file.language = formatType;
      editor.setOption('mode', getCodeMirrorMode(formatType));
      updateLanguage(getLanguageDisplayName(formatType));

      const content = editor.getValue();
      let formatted;

      try {
        if (formatType === 'json') {
          formatted = formatJSON(content);
        } else if (formatType === 'xml') {
          formatted = formatXML(content);
        } else if (formatType === 'html') {
          formatted = formatHTML(content);
        } else {
          updateStatus('Unknown format type: ' + formatType);
          return;
        }

        if (formatted !== null && formatted !== content) {
          isLoadingContent = true;
          editor.setValue(formatted);
          isLoadingContent = false;
          file.isDirty = true;
          updateFilesList();
          updateTitle();
          updateStatus('Document formatted as ' + formatType.toUpperCase());
        } else {
          updateStatus('Document highlighted as ' + formatType.toUpperCase());
        }
      } catch (err) {
        updateStatus('Format error: ' + err.message);
      }
    }

    function showFormatModal(file) {
      const ext = file.filePath ? path.extname(file.filePath).toLowerCase() : '';
      const msg = ext
        ? 'Choose a format type for ' + ext + ' files:'
        : 'Choose a format type:';
      document.getElementById('format-modal-message').textContent = msg;

      const rememberLabel = document.getElementById('format-remember-label');
      if (ext) {
        rememberLabel.classList.remove('hidden');
        document.getElementById('format-remember-text').textContent =
          'Always use this format for ' + ext + ' files';
      } else {
        rememberLabel.classList.add('hidden');
      }

      document.getElementById('format-remember-checkbox').checked = false;
      document.getElementById('format-type-select').value = 'xml';
      document.getElementById('format-modal').classList.remove('hidden');
    }

    function formatDocument() {
      const file = getActiveFile();
      if (!file) {
        updateStatus('No file open');
        return;
      }

      const formatType = getFormatType(file);
      if (formatType) {
        applyFormat(formatType);
      } else {
        showFormatModal(file);
      }
    }

    function formatJSON(content) {
      const parsed = JSON.parse(content);
      return JSON.stringify(parsed, null, 2);
    }

    function formatXML(content) {
      const PADDING = '  ';
      let formatted = '';
      let indent = 0;

      // Remove existing whitespace between tags
      const xml = content.replace(/>\s*</g, '><').trim();

      xml.split(/(<[^>]+>)/g).forEach(node => {
        if (!node.trim()) return;

        if (node.match(/^<\?/)) {
          // XML declaration
          formatted += node + '\n';
        } else if (node.match(/^<\//)) {
          // Closing tag
          indent--;
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^<[^/].*[^/]>$/)) {
          // Opening tag (not self-closing)
          formatted += PADDING.repeat(indent) + node + '\n';
          indent++;
        } else if (node.match(/^<.*\/>$/)) {
          // Self-closing tag
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^</)) {
          // Other tags
          formatted += PADDING.repeat(indent) + node + '\n';
        } else {
          // Text content
          if (node.trim()) {
            formatted += PADDING.repeat(indent) + node.trim() + '\n';
          }
        }
      });

      return formatted.trim();
    }

    function formatHTML(content) {
      const PADDING = '  ';
      let formatted = '';
      let indent = 0;

      // Inline elements that shouldn't force newlines
      const inlineElements = ['a', 'span', 'strong', 'em', 'b', 'i', 'u', 'small', 'code', 'br', 'img'];
      // Void elements (self-closing)
      const voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

      // Remove existing whitespace between tags
      const html = content.replace(/>\s+</g, '><').trim();

      html.split(/(<[^>]+>)/g).forEach(node => {
        if (!node.trim()) return;

        const tagMatch = node.match(/^<\/?(\w+)/);
        const tagName = tagMatch ? tagMatch[1].toLowerCase() : '';

        if (node.match(/^<!DOCTYPE/i)) {
          // DOCTYPE
          formatted += node + '\n';
        } else if (node.match(/^<!--/)) {
          // Comment
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^<\//)) {
          // Closing tag
          indent = Math.max(0, indent - 1);
          formatted += PADDING.repeat(indent) + node + '\n';
        } else if (node.match(/^<[^/]/) && !voidElements.includes(tagName)) {
          // Opening tag (not void)
          formatted += PADDING.repeat(indent) + node + '\n';
          indent++;
        } else if (node.match(/^</)) {
          // Void/self-closing tag
          formatted += PADDING.repeat(indent) + node + '\n';
        } else {
          // Text content
          if (node.trim()) {
            formatted += PADDING.repeat(indent) + node.trim() + '\n';
          }
        }
      });

      return formatted.trim();
    }

    function updateTitle() {
      const file = getActiveFile();
      if (file) {
        const fileName = file.filePath ? path.basename(file.filePath) : 'Untitled';
        document.title = (file.isDirty ? '* ' : '') + fileName + ' - Text Editor';
      } else {
        document.title = 'Text Editor';
      }
    }

    function updateStatus(text) {
      document.getElementById('status-text').textContent = text;
    }

    function updatePosition(line, col) {
      document.getElementById('status-position').textContent = 'Ln ' + line + ', Col ' + col;
    }

    function updateEncoding(encoding) {
      document.getElementById('status-encoding').textContent = encoding;
    }

    function updateLanguage(language) {
      document.getElementById('status-language').textContent = language;
    }

    function updateFilesList() {
      const container = document.getElementById('files-list');
      container.innerHTML = '';

      openFiles.forEach(file => {
        const div = document.createElement('div');
        div.className = 'file-item' +
          (file.id === activeFileId ? ' active' : '') +
          (file.isDirty ? ' modified' : '');

        const nameSpan = document.createElement('span');
        nameSpan.className = 'file-name';
        nameSpan.textContent = file.filePath ? path.basename(file.filePath) : 'Untitled';
        nameSpan.title = file.filePath || 'Untitled';

        div.appendChild(nameSpan);

        // Only show close button for non-modified files
        if (!file.isDirty) {
          const closeBtn = document.createElement('span');
          closeBtn.className = 'file-close';
          closeBtn.textContent = '×';
          closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeFile(file.id);
          });
          div.appendChild(closeBtn);
        }

        div.addEventListener('click', () => switchToFile(file.id));
        container.appendChild(div);
      });
    }

    function getCodeMirrorMode(language) {
      const modes = {
        'html': 'htmlmixed',
        'xml': 'xml',
        'json': { name: 'javascript', json: true },
        'javascript': 'javascript',
        'typescript': { name: 'javascript', typescript: true },
        'css': 'css',
        'scss': 'text/x-scss',
        'less': 'text/x-less',
        'csharp': 'text/x-csharp',
        'c': 'text/x-csrc',
        'cpp': 'text/x-c++src',
        'java': 'text/x-java',
        'python': 'python',
        'sql': 'sql',
        'markdown': 'markdown',
        'yaml': 'yaml',
        'plaintext': 'text/plain'
      };
      return modes[language] || 'text/plain';
    }

    function getLanguageDisplayName(lang) {
      const names = {
        'plaintext': 'Plain Text',
        'html': 'HTML',
        'xml': 'XML',
        'json': 'JSON',
        'javascript': 'JavaScript',
        'typescript': 'TypeScript',
        'csharp': 'C#',
        'css': 'CSS',
        'scss': 'SCSS',
        'less': 'Less',
        'java': 'Java',
        'sql': 'SQL',
        'c': 'C',
        'cpp': 'C++',
        'python': 'Python',
        'markdown': 'Markdown',
        'yaml': 'YAML'
      };
      return names[lang] || lang;
    }

    function getLanguageFromPath(filePath) {
      const ext = path.extname(filePath).toLowerCase();
      const map = {
        '.html': 'html',
        '.htm': 'html',
        '.xml': 'xml',
        '.xaml': 'xml',
        '.json': 'json',
        '.js': 'javascript',
        '.jsx': 'javascript',
        '.mjs': 'javascript',
        '.ts': 'typescript',
        '.tsx': 'typescript',
        '.cs': 'csharp',
        '.css': 'css',
        '.scss': 'scss',
        '.less': 'less',
        '.java': 'java',
        '.sql': 'sql',
        '.c': 'c',
        '.h': 'c',
        '.cpp': 'cpp',
        '.hpp': 'cpp',
        '.py': 'python',
        '.md': 'markdown',
        '.yaml': 'yaml',
        '.yml': 'yaml',
        '.txt': 'plaintext'
      };
      return map[ext] || 'plaintext';
    }

    // Search and replace state
    let searchMarks = [];
    let searchMatches = [];
    let currentMatchIndex = -1;

    function toggleSearchPanel() {
      const panel = document.getElementById('search-panel');
      if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        const selection = editor.getSelection();
        if (selection) {
          document.getElementById('search-input').value = selection;
        }
        document.getElementById('search-input').focus();
        document.getElementById('search-input').select();
        if (document.getElementById('search-input').value) {
          performSearch();
        }
      } else {
        closeSearchPanel();
      }
    }

    function closeSearchPanel() {
      document.getElementById('search-panel').classList.add('hidden');
      clearSearchHighlights();
      editor.focus();
    }

    function clearSearchHighlights() {
      searchMarks.forEach(m => m.clear());
      searchMarks = [];
      searchMatches = [];
      currentMatchIndex = -1;
      document.getElementById('search-count').textContent = 'No results';
    }

    function performSearch() {
      clearSearchHighlights();
      const query = document.getElementById('search-input').value;
      if (!query) return;

      const caseSensitive = document.getElementById('search-case').checked;
      const useRegex = document.getElementById('search-regex').checked;

      let searchQuery;
      if (useRegex) {
        try {
          searchQuery = new RegExp(query, caseSensitive ? 'g' : 'gi');
        } catch (e) {
          document.getElementById('search-count').textContent = 'Invalid regex';
          return;
        }
      } else {
        searchQuery = query;
      }

      const cursor = editor.getSearchCursor(searchQuery, null, !caseSensitive);
      while (cursor.findNext()) {
        const from = cursor.from();
        const to = cursor.to();
        searchMatches.push({ from, to });
        const mark = editor.markText(from, to, { className: 'search-highlight' });
        searchMarks.push(mark);
      }

      if (searchMatches.length > 0) {
        // Find the match closest to the current cursor position
        const cursorPos = editor.getCursor();
        let bestIndex = 0;
        for (let i = 0; i < searchMatches.length; i++) {
          const match = searchMatches[i];
          if (match.from.line > cursorPos.line ||
              (match.from.line === cursorPos.line && match.from.ch >= cursorPos.ch)) {
            bestIndex = i;
            break;
          }
          bestIndex = i;
        }
        highlightCurrentMatch(bestIndex);
      } else {
        document.getElementById('search-count').textContent = 'No results';
      }
    }

    function highlightCurrentMatch(index) {
      // Remove previous current highlight
      if (currentMatchIndex >= 0 && currentMatchIndex < searchMarks.length) {
        searchMarks[currentMatchIndex].clear();
        const prev = searchMatches[currentMatchIndex];
        searchMarks[currentMatchIndex] = editor.markText(prev.from, prev.to, { className: 'search-highlight' });
      }

      currentMatchIndex = index;
      const match = searchMatches[currentMatchIndex];

      // Apply current highlight
      searchMarks[currentMatchIndex].clear();
      searchMarks[currentMatchIndex] = editor.markText(match.from, match.to, { className: 'search-highlight-current' });

      editor.scrollIntoView({ from: match.from, to: match.to }, 50);
      editor.setCursor(match.from);

      document.getElementById('search-count').textContent =
        (currentMatchIndex + 1) + ' of ' + searchMatches.length;
    }

    function navigateMatch(direction) {
      if (searchMatches.length === 0) {
        performSearch();
        return;
      }

      let newIndex = currentMatchIndex + direction;
      if (newIndex >= searchMatches.length) newIndex = 0;
      if (newIndex < 0) newIndex = searchMatches.length - 1;
      highlightCurrentMatch(newIndex);
    }

    function replaceCurrent() {
      if (currentMatchIndex < 0 || currentMatchIndex >= searchMatches.length) return;
      const replaceText = document.getElementById('replace-input').value;
      const match = searchMatches[currentMatchIndex];

      editor.replaceRange(replaceText, match.from, match.to);
      performSearch();
    }

    function replaceAll() {
      if (searchMatches.length === 0) return;
      const replaceText = document.getElementById('replace-input').value;
      const count = searchMatches.length;

      editor.operation(() => {
        // Replace from bottom to top to preserve positions
        for (let i = searchMatches.length - 1; i >= 0; i--) {
          editor.replaceRange(replaceText, searchMatches[i].from, searchMatches[i].to);
        }
      });

      clearSearchHighlights();
      updateStatus('Replaced ' + count + ' occurrence' + (count !== 1 ? 's' : ''));
    }

    // Keyboard shortcuts for search
    document.addEventListener('keydown', (e) => {
      const mod = process.platform === 'darwin' ? e.metaKey : e.ctrlKey;
      if (mod && e.key === 'f') {
        e.preventDefault();
        if (document.getElementById('search-panel').classList.contains('hidden')) {
          toggleSearchPanel();
        } else {
          document.getElementById('search-input').focus();
          document.getElementById('search-input').select();
        }
      } else if (mod && e.key === 'h') {
        e.preventDefault();
        if (document.getElementById('search-panel').classList.contains('hidden')) {
          toggleSearchPanel();
        }
        document.getElementById('replace-input').focus();
      }
    });

    // Drag and drop file opening (capture phase to intercept before CodeMirror)
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, true);
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      const file = e.dataTransfer.files[0];
      if (!file) return;
      const filePath = webUtils.getPathForFile(file);
      if (!filePath) return;
      const data = await ipcRenderer.invoke('reload-file', { filePath });
      if (data) {
        loadFile(data);
        ipcRenderer.send('add-recent-file', filePath);
      }
    }, true);

    // Initialize - create a new empty file on startup
    newFile();
  </script>
</body>
</html>
